<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>hzhuang的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="华中科技大学13级硕士，在读。想从事前端类工作，努力奋进中。。。">
<meta property="og:type" content="website">
<meta property="og:title" content="hzhuang的博客">
<meta property="og:url" content="http://huangzhuang.github.io/index.html">
<meta property="og:site_name" content="hzhuang的博客">
<meta property="og:description" content="华中科技大学13级硕士，在读。想从事前端类工作，努力奋进中。。。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="hzhuang的博客">
<meta name="twitter:description" content="华中科技大学13级硕士，在读。想从事前端类工作，努力奋进中。。。">
  
    <link rel="alternative" href="/atom.xml" title="hzhuang的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://hz2015.sinaapp.com/static/images/zhuang.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">hzhuang</a></h1>
		</hgroup>

		
		<p class="header-subtitle">人若无名，便可专心练剑！</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags/css3">css3</a></li>
				        
							<li><a href="/tags/js">javascript</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/huangzhuang" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/1875236755/profile?topnav=1&wvr=6" title="weibo">weibo</a>
					        
								<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/huang-zhuang-225" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/MVC/" style="font-size: 10px;">MVC</a> <a href="/tags/animation/" style="font-size: 10px;">animation</a> <a href="/tags/autosize/" style="font-size: 10px;">autosize</a> <a href="/tags/codewars/" style="font-size: 10px;">codewars</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/css3/" style="font-size: 16px;">css3</a> <a href="/tags/debug/" style="font-size: 10px;">debug</a> <a href="/tags/iscroll/" style="font-size: 10px;">iscroll</a> <a href="/tags/js/" style="font-size: 20px;">js</a> <a href="/tags/js-sdk/" style="font-size: 10px;">js-sdk</a> <a href="/tags/learning/" style="font-size: 14px;">learning</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/reqexp/" style="font-size: 10px;">reqexp</a> <a href="/tags/transition/" style="font-size: 10px;">transition</a> <a href="/tags/webview/" style="font-size: 10px;">webview</a> <a href="/tags/代码规范/" style="font-size: 12px;">代码规范</a> <a href="/tags/前端/" style="font-size: 18px;">前端</a> <a href="/tags/前端框架/" style="font-size: 10px;">前端框架</a> <a href="/tags/学习笔记/" style="font-size: 10px;">学习笔记</a> <a href="/tags/录音/" style="font-size: 10px;">录音</a> <a href="/tags/微信/" style="font-size: 10px;">微信</a> <a href="/tags/模仿qq/" style="font-size: 10px;">模仿qq</a> <a href="/tags/笔记/" style="font-size: 10px;">笔记</a> <a href="/tags/简书/" style="font-size: 10px;">简书</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a> <a href="/tags/选择器/" style="font-size: 10px;">选择器</a> <a href="/tags/高级程序/" style="font-size: 10px;">高级程序</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">华中科技大学13级硕士，在读。想从事前端类工作，努力奋进中。。。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">hzhuang</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://hz2015.sinaapp.com/static/images/zhuang.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">hzhuang</h1>
			</hgroup>
			
			<p class="header-subtitle">人若无名，便可专心练剑！</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/css3">css3</a></li>
		        
					<li><a href="/tags/js">javascript</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/huangzhuang" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/1875236755/profile?topnav=1&wvr=6" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/huang-zhuang-225" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    
<article id="post-wx-debug" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/15/wx-debug/" class="article-date">
  	<time datetime="2015-12-14T19:51:00.000Z" itemprop="datePublished">2015-12-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/15/wx-debug/">微信X5内核webview调试</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
<a href="https://unsplash.it/1568/500/?random" title="" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://unsplash.it/1568/500/?random" title=""></a>

      <div class="entry">
      
        <h1 id="题记">题记</h1><p>记得在简书中很早就发现并收藏这篇文章了，但是点进去一看，又是tbs又是java和android，被吓傻了，果断关了网页。而后的契机（主要有大神带啦）让我重新来学习这篇文章，原因有几个：</p>
      
    </div>

    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/debug/">debug</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webview/">webview</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/微信/">微信</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/12/15/wx-debug/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    
<article id="post-whlove-record-introduction" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/26/whlove-record-introduction/" class="article-date">
  	<time datetime="2015-11-26T14:00:00.000Z" itemprop="datePublished">2015-11-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/26/whlove-record-introduction/">武汉高校之恋-语音介绍页面实现总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
<a href="https://unsplash.it/1568/500/?random" title="" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://unsplash.it/1568/500/?random" title=""></a>

      <div class="entry">
      
        <div id="toc" class="toc-article">
    <strong class="toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#任务实现"><span class="toc-text">任务实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#其他"><span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#毛玻璃效果"><span class="toc-text">毛玻璃效果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于播放的按钮"><span class="toc-text">关于播放的按钮</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于微信页面的调试"><span class="toc-text">关于微信页面的调试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#更新1"><span class="toc-text">更新1</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#关于手按住手机屏幕计时停止"><span class="toc-text">关于手按住手机屏幕计时停止</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#更新2"><span class="toc-text">更新2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#关于毛玻璃的最终解决方案"><span class="toc-text">关于毛玻璃的最终解决方案</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#更新3"><span class="toc-text">更新3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#关于audio的播放和停止切换的方法"><span class="toc-text">关于audio的播放和停止切换的方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#更新4"><span class="toc-text">更新4</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#关于录音中退出页面后再调用录音接口失败"><span class="toc-text">关于录音中退出页面后再调用录音接口失败</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#更新5"><span class="toc-text">更新5</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#关于在非wechat中的提示问题"><span class="toc-text">关于在非wechat中的提示问题</span></a></li></ol></li></ol>
</div>

      
        <a id="more"></a>
<h1 id="任务实现">任务实现</h1><ul>
<li><p>设计图<br><img src="http://hz2015.sinaapp.com/static/images/design-record.jpg" alt="设计图"></p>
</li>
<li><p>根据设计图，步骤如下：<br>1.实现微信js-sdk的录音，播放，暂停的接口！具体做法是在个人页面中设定三个按钮，分别对应！<br>2.弹窗：背景图片先写好样式，然后点击弹窗，由于毛玻璃效果不佳（后面细说），背景暂时没调！然后分别作出开始录制、结束录制和重播以及发布页面（新设计图）！<br>3.实现初步交互过程：也就是说点击开始录制出现第二界面……(界面中的切换)。当时为了练手visio，还画了一个很low的图。<br><img src="http://hz2015.sinaapp.com/static/images/interaction1.png" alt="初步交互逻辑图"><br>4.圆形进度条：计时的问题，这个可以js实现！并不难，关于实时进度条的问题！<br>关于圆形进度条，可以参考以下：</p>
<ul>
<li><a href="http://www.w3cplus.com/css3/create-radial-progress-bar-with-jQuery-and-css3.html" target="_blank" rel="external">参考一</a></li>
<li><a href="http://www.tuicool.com/articles/AVRvmqm" target="_blank" rel="external">参考二</a><br>但是，我现在实现的实时是每秒会转6度，看起来不连续，现在有个新思路，就是和js独立开，点击开始录音的话，js计时，此时动画开始（先右边转180度，然后左边再转180度，动画排队问题）。当点击结束录音的时候，动画停止!</li>
</ul>
<p>5.功能交互部分：<br><img src="http://hz2015.sinaapp.com/static/images/func-interaction.png" alt="功能交互图"><br>基本实现的差不多了！</p>
<p>6.播放自己录音或者听别人录音的交互部分。<br>由后台传回的ogg格式的音频文件，在页面中使用html5的audio！<br>但是注意：</p>
<hr>
<p><strong>苹果手机不支持ogg格式的文件！所以改成后台传回mp3格式！问题ok</strong></p>
<hr>
<p>7.bug检测，以及修复</p>
</li>
</ul>
<h1 id="其他">其他</h1><h2 id="毛玻璃效果">毛玻璃效果</h2><p>这是一个很炫酷的效果，但是对于图片好实现，但是对于要作为整个div块的话，实现有难度！<br>实现方法可以从几个方向：<br>1.filter的方法,微信浏览器支持性问题。<br>2.svg的方法。无效<br>3.canvas：但是效果针对resterized image，所以在此需求不符。<br>4.用背景图片的方法，没有达到效果。<br>5.要关注的是backdrop filter<br>6.高端玩法：先将当前页面截屏，然后在用canvas虚化！<br>参考文献：<br><a href="http://www.zhangxinxu.com/wordpress/2013/11/%E5%B0%8Ftip-%E4%BD%BF%E7%94%A8css%E5%B0%86%E5%9B%BE%E7%89%87%E8%BD%AC%E6%8D%A2%E6%88%90%E6%A8%A1%E7%B3%8A%E6%AF%9B%E7%8E%BB%E7%92%83%E6%95%88%E6%9E%9C/" target="_blank" rel="external">张鑫旭的文章</a><br><a href="https://www.webkit.org/blog/3632/introducing-backdrop-filters/" target="_blank" rel="external">backdrop-filter</a></p>
<h2 id="关于播放的按钮">关于播放的按钮</h2><p>暂停的三角不是应该中线对其，而是应该三个角对应圆周的距离相等。@skyway</p>
<h2 id="关于微信页面的调试">关于微信页面的调试</h2><ul>
<li><a href="http://blog.qqbrowser.cc/" target="_blank" rel="external">微信自己研发的调试工具</a><br>可以看js错误，支持断点，可以调试页面，但是console.log不输出！</li>
<li><a href="http://jsconsole.com/" target="_blank" rel="external">jsconsole</a></li>
<li>weinre</li>
</ul>
<p>暂时先写这些吧，再更新！</p>
<h1 id="更新1">更新1</h1><h2 id="关于手按住手机屏幕计时停止">关于手按住手机屏幕计时停止</h2><ul>
<li>mask出现，让屏幕overflow:hidden。但是。。。问题没这么简单！</li>
<li>必须是html和body同时设定才可以，不然只有pc端达到效果，但是微信端是没有效果的！</li>
</ul>
<pre><code>但是，事情往往没有这么简单，安卓手机上基本是已经没有问题了，但是坑爹的ios是这样的，它还可以上下滑，虽然没有了<span class="value">scroll</span>。
</code></pre><p>解决方法就是：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'body'</span>).on(<span class="string">'touchmove'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;event.preventDefault();&#125;); <span class="comment">//mask出现时。</span></span><br><span class="line">$(<span class="string">'body'</span>).unbind();<span class="comment">//取消mask时。</span></span><br></pre></td></tr></table></figure></p>
<h1 id="更新2">更新2</h1><h2 id="关于毛玻璃的最终解决方案">关于毛玻璃的最终解决方案</h2><ul>
<li>安卓上是那种很low的纯色，估计是设计打架没有打过那个PM吧！</li>
<li>ios上由于支持<code>filter:blur(15px)</code>所以事先的是毛玻璃的效果。<br><a href="http://x5.tencent.com/guide?id=2002%E3%80%81" target="_blank" rel="external">qqX5内核常见问题</a><br>虽然微信的服务器比这坑的多，不过也是可以参考一二的！<br>代码如下：</li>
</ul>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">u</span> = navigator.userAgent, <span class="keyword">app</span> = navigator.appVersion;</span><br><span class="line"><span class="keyword">var</span> isAndroid = <span class="keyword">u</span>.indexOf('Android') &gt; -1;</span><br><span class="line"><span class="keyword">var</span> isiOS = !!<span class="keyword">u</span>.<span class="literal">match</span>(/\(i[^;]+;( <span class="keyword">U</span>;)? CPU.+<span class="keyword">Mac</span> OS X/);</span><br></pre></td></tr></table></figure>
<h1 id="更新3">更新3</h1><h2 id="关于audio的播放和停止切换的方法">关于audio的播放和停止切换的方法</h2><p>就是通过<strong>audio.src</strong>来切换。<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(audio_url)&#123;</span><br><span class="line">    <span class="keyword">if</span>(audio.paused)&#123;</span><br><span class="line">        audio.src= audio_url;</span><br><span class="line">        audio.<span class="keyword">play</span>();</span><br><span class="line">        <span class="variable">$(</span><span class="string">".record_play_icon .play"</span>).html(<span class="string">"&amp;#x5799;"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        audio.<span class="keyword">pause</span>();</span><br><span class="line">        <span class="variable">$(</span><span class="string">".record_play_icon .play"</span>).html(<span class="string">"&amp;#x5798;"</span>);</span><br><span class="line">        audio.src= <span class="string">" "</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    alert(<span class="string">"请先录音！"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="更新4">更新4</h1><h2 id="关于录音中退出页面后再调用录音接口失败">关于录音中退出页面后再调用录音接口失败</h2><p>错误原因是recording<br>解决方案：在每次调用开始录音的接口是先执行一次wx_stopRecord()</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wx.stopRecord<span class="comment">()</span>;</span><br><span class="line"><span class="keyword">if</span><span class="comment">(wx_record)</span>&#123;</span><br><span class="line">    wx.startRecord<span class="comment">(&#123;</span><br><span class="line">    ......</span></span><br></pre></td></tr></table></figure>
<h1 id="更新5">更新5</h1><h2 id="关于在非wechat中的提示问题">关于在非wechat中的提示问题</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 判断能否使用微信接口</span><br><span class="line">var wx_support = <span class="keyword">false</span>;</span><br><span class="line">var wx_record = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">wx.ready(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">   wx.checkJsApi(&#123;</span><br><span class="line">        jsApiList: [<span class="string">'chooseImage'</span>,<span class="string">'startRecord'</span>,], // 需要检测的JS接口列表</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span><span class="params">(res)</span></span> &#123;</span><br><span class="line">//console.log(<span class="string">'ok'</span>);</span><br><span class="line">// 以键值对的形式返回，可用的api值<span class="keyword">true</span>，不可用为<span class="keyword">false</span></span><br><span class="line">// 如：&#123;<span class="string">"checkResult"</span>:&#123;<span class="string">"chooseImage"</span>:<span class="keyword">true</span>&#125;,<span class="string">"errMsg"</span>:<span class="string">"checkJsApi:ok"</span>&#125;</span><br><span class="line">        <span class="keyword">if</span>(res[<span class="string">'checkResult'</span>][<span class="string">'chooseImage'</span>])&#123;</span><br><span class="line">            //alert(<span class="string">'ok'</span>);</span><br><span class="line">            wx_support = <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            wx_support = <span class="keyword">false</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span>(res[<span class="string">'checkResult'</span>][<span class="string">'startRecord'</span>])&#123;</span><br><span class="line">            wx_record = <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            wx_record = <span class="keyword">false</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 蛋疼呀？但是不稳定，还是分开写吧！</span><br><span class="line">        // <span class="keyword">if</span>(res[<span class="string">'checkResult'</span>][<span class="string">'chooseImage'</span>] &amp;&amp; res[<span class="string">'checkResult'</span>][<span class="string">'startRecord'</span>])&#123;</span><br><span class="line">        //     alert(<span class="string">"I am True"</span>);</span><br><span class="line">        // &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

      
    </div>

    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js-sdk/">js-sdk</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/录音/">录音</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    
<article id="post-codewars" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/20/codewars/" class="article-date">
  	<time datetime="2015-09-20T08:26:54.321Z" itemprop="datePublished">2015-09-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/20/codewars/">每日一战(codewars)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
<a href="https://unsplash.it/1568/500/?random" title="" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://unsplash.it/1568/500/?random" title=""></a>

      <div class="entry">
      
        <p>#1.DNA<br>题目：</p>
<blockquote>
<p>In DNA strings, symbols “A” and “T” are complements of each other, as “C” and “G”. You have function with one side of the DNA (string, except for Haskell); you need to get the other complementary side. DNA strand is never empty or there is no DNA at all (again, except for Haskell).<br>DNAStrand (“ATTGC”) # return “TAACG”<br>DNAStrand (“GTAT”) # return “CATA”</p>
</blockquote>
<p>以下的解决方法是摘录并分析掌握：</p>
<p>解决一：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DNAStrand</span><span class="params">(dna)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> dna.replace(/./g, <span class="function"><span class="keyword">function</span><span class="params">(c)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> DNAStrand.<span class="built_in">pairs</span>[c]</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DNAStrand.<span class="built_in">pairs</span> = &#123;</span><br><span class="line">  A: <span class="string">'T'</span>,</span><br><span class="line">  T: <span class="string">'A'</span>,</span><br><span class="line">  C: <span class="string">'G'</span>,</span><br><span class="line">  G: <span class="string">'C'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
      
    </div>

    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/codewars/">codewars</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/09/20/codewars/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    
<article id="post-angular-nextWeb" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/23/angular-nextWeb/" class="article-date">
  	<time datetime="2015-07-23T01:30:30.000Z" itemprop="datePublished">2015-07-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/23/angular-nextWeb/">angular.js开发下一代web读书笔记</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
<a href="https://unsplash.it/1568/500/?random" title="" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://unsplash.it/1568/500/?random" title=""></a>

      <div class="entry">
      
        <div id="toc" class="toc-article">
    <strong class="toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#模板和数据绑定"><span class="toc-text">模板和数据绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#列表，表格以及其他迭代性元素"><span class="toc-text">列表，表格以及其他迭代性元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#隐藏和显示"><span class="toc-text">隐藏和显示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#css类与样式"><span class="toc-text">css类与样式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用Module组织依赖关系"><span class="toc-text">使用Module组织依赖关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用过滤器格式化数据"><span class="toc-text">使用过滤器格式化数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用指令修改DOM"><span class="toc-text">使用指令修改DOM</span></a></li></ol></li></ol>
</div>

      
        <a id="more"></a>
<p>##谈到angular.js可以想到什么？</p>
<ul>
<li>核心特性:MVC，模块化，自动化双向数据绑定，语义化标签，依赖注入(首次应用于前端框架。)。</li>
<li>TDD(测试驱动)。</li>
<li>解决html实现动态页面的困难。</li>
</ul>
<p>#angular框架中的基本概念</p>
<p>##1.客户端模板<br>区别于基于ajax的单页面是在服务器端装配模板和data，然后把生成的页面发送到浏览器。而angular.js是服务器把数据和模板都发到浏览器，然后再客户端中进行装配。<br><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"HelloController"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">p</span>&gt;</span></span><span class="expression">&#123;&#123;<span class="variable">greeting.text</span>&#125;&#125;</span><span class="xml">, world<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 应用逻辑 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="actionscript"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">HelloController</span><span class="params">($scope)</span></span>&#123;</span><br><span class="line">		$scope.greeting = &#123;text: <span class="string">"Hello"</span>&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>$scope对象是模板的<strong>域模型</strong>，也称为作用域实例，为其赋值，可以传到模板中渲染。<br>$scope对象可以精确的控制域模型的那些数据和操作在视图上是有效的。</p>
<p>其中，使用的是google的CDN。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"https://ajax.googleapis.com/ajax/libs/angularjs/1.2.0/angular.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>##2.MVC<br>model:管理数据的代码; angular.js中就是存储数据的对象。<br>controller：应用逻辑代码; angular.js中就是js类。<br>view：展示数据的代码; angular.js中DOM。</p>
<p><img src="http://hz2015.sinaapp.com/static/pictures/MVC.png" alt="MVC逻辑图"></p>
<p>##3.数据绑定<br>最新的数据插入到UI中，或者用户的输入修改数据。不必要使用代码来实现。使用<strong>映射</strong>让它们自动同步: UI中的某个部分映射某个js的属性。<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="class"><span class="keyword">type</span></span>=<span class="string">"text"</span> ng-model=<span class="string">"greeting.text"</span>&gt;;</span><br></pre></td></tr></table></figure></p>
<p>##4.依赖注入<br>只需要简单的获取它们所需要的东西，而不需要创建那些它们所依赖的东西。比如$scope。</p>
<p>##5.指令<br>把模板编写成HTML的形式。因为angular引入了一款强大的DOM转换引擎，可以扩展HTML的语法。</p>
<p>ng-app: 告诉angular页面中的哪些部分需要接受它的管理。<br>ng-xxxController: 控制器。<br>ng-repeat:<br>ng-click: 点击触发的事件。</p>
<p>#AngularJs应用骨架</p>
<p>##调用Angular</p>
<ul>
<li>加载angular.js库。</li>
<li>ng-app指令指定angular管理的DOM部分。</li>
</ul>
<p>###加载脚本<br>CDN:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"https://ajax.googleapis.com/ajax/libs/angularjs/1.2.0/angular.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>google服务器快，而且可以在多个应用之间缓存脚本库。</p>
<p>###使用ng-app声明Angular的边界<br>如果要打造一款纯angular应用，则可以把ng-app指令放在html标签内。</p>
<p>#Model View Controller</p>
<ul>
<li>容纳数据的模型</li>
<li>展示数据的视图</li>
<li>管理模块和视图之间关系的控制器</li>
</ul>
<p>双括号插值语法</p>
<p>控制器就是编写的类，告诉angular这个模型是由哪些对象或者基本数据构成的。<br>如果数据少的话可以直接用基本数据存储，但是大部分的时候是创建模型对象来容纳数据。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	<span class="keyword">function</span> TextController(<span class="variable">$scope</span>)&#123;</span><br><span class="line">		var messages = &#123;&#125;;</span><br><span class="line">		messages.sometext = <span class="string">"huangzhuang.github.io"</span>;</span><br><span class="line">		<span class="variable">$scope</span>.messages = messages;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>事实上，控制器的编写不应该实在全局命名空间的，所以正确的做法就是应该把它定义成模块的一部分，然后使用命名空间机制。如下：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;html ng-app = <span class="string">"hzhuang-app"</span>&gt;</span><br><span class="line">...</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	var appModuel = angular.module(<span class="string">"hzhuang-app"</span>,[]);</span><br><span class="line">	//angular对象创建名为hzhuang-app的模块。后面的空数组表示不依赖其他模块。</span><br><span class="line">	appModuel.controller(<span class="string">"TextController"</span>, <span class="keyword">function</span>(<span class="variable">$scope</span>)&#123; </span><br><span class="line">	//控制器函数传递给appModuel的consroller函数</span><br><span class="line">		var messages = &#123;&#125;;</span><br><span class="line">		messages.sometext = <span class="string">"huangzhuang.github.io"</span>;</span><br><span class="line">		<span class="variable">$scope</span>.messages = messages;</span><br><span class="line">	&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="模板和数据绑定">模板和数据绑定</h2><p>工作流程：<br><img src="http://hz2015.sinaapp.com/static/pictures/angular-workflow.png" alt=""></p>
<p>###显示文本<br>ng-bind指令<br>虽然双括号插值法也可以，但是这种方法会导致没有渲染好模块会直接显示给用户一段时间的问题。</p>
<p>###表单输入<br>ng-model属性把元素绑定到模型属性上。<br>ng-change属性指定一个控制器方法，一旦用户修改了输入值，这个方法就会被调用。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;form ng-controller=<span class="string">"StartUpController"</span>&gt;</span><br><span class="line">	Starting: &lt;input type=<span class="string">"text"</span> ng-change = <span class="string">"computeNeeded()"</span> ng-model=<span class="string">"funding.startingEstimate"</span>&gt;</span><br><span class="line">	Recommendation: &#123;&#123;funding.needed&#125;&#125;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	<span class="keyword">function</span> StartUpController(<span class="variable">$scope</span>)&#123;</span><br><span class="line">		<span class="variable">$scope</span>.funding = &#123;startingEstimate: <span class="number">0</span>&#125;;</span><br><span class="line">		<span class="variable">$scope</span>.computeNeeded = function()&#123;</span><br><span class="line">			<span class="variable">$scope</span>.funding.needed = <span class="variable">$scope</span>.funding.startingEstimate * <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>以上的实例会有一个问题：如果还有其他的输入框也绑定到模型的这个属性上，如果接受到服务器端的数据，就会导致模型刷新。<br>so，$scope对象的$watch()函数来解决这个问题。它来监视一个表达式，当这个表达式发生变化的时候就会调用一个回调函数。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	<span class="keyword">function</span> StartUpController(<span class="variable">$scope</span>)&#123;</span><br><span class="line">		<span class="variable">$scope</span>.funding = &#123;startingEstimate: <span class="number">0</span>&#125;;</span><br><span class="line">		computeNeeded = function()&#123;</span><br><span class="line">			<span class="variable">$scope</span>.funding.needed = <span class="variable">$scope</span>.funding.startingEstimate * <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="variable">$scope</span>.<span class="variable">$watch</span>(<span class="string">"funding.startingEstimate"</span>, computeNeeded);</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>ng-submit在提交表格的时候执行。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="tag">form</span> ng-controller=<span class="string">"StartUpController"</span> ng-submit=<span class="string">"requestFunding()"</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>在提交表单的时候，ng-submit会自动组织浏览器执行默认的POST操作。<br>ng-click<br>ng-dbclick</p>
<p>###浅谈非入侵式javascript</p>
<ul>
<li>并不是所有的浏览器都支持js。</li>
<li>有人会使用非常奇怪的浏览器，屏幕阅读器。</li>
<li>在不同的方式运行的效果不同。</li>
<li>事件处理都在全局，不同库相同函数名会冲突。</li>
<li>时间监听会绑定数据结构和行为，难以维护、扩展和理解。</li>
</ul>
<p>对于angular而言，以上的第三点和第四点，对于内联的时间监听有等价的形式ng-eventhandler = “xxx”。<br>优点：</p>
<ul>
<li>屏蔽不同浏览器的差异性。</li>
<li>不会在全局命名空间中操作。</li>
</ul>
<p>对于第五点，angular处理的时候根本就没有引用DOM，都是在内部完成的。</p>
<h3 id="列表，表格以及其他迭代性元素">列表，表格以及其他迭代性元素</h3><p>主要就是详细讲解<strong>ng-repeat</strong></p>
<p>$index返回当前引用的元素序号,类似的是$middle还有$last</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul ng-controller=<span class="string">"StudentListController"</span>&gt;</span><br><span class="line">	&lt;li ng-repeat = <span class="string">"student in students"</span>&gt;</span><br><span class="line">		&lt;a href=<span class="string">"#"</span>&gt;&#123;&#123;student.name&#125;&#125; + &#123;&#123;<span class="variable">$index</span>&#125;&#125;&lt;/a&gt;</span><br><span class="line">	&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	var students = [</span><br><span class="line">		&#123;name : <span class="string">"hzhuang"</span> , id : <span class="number">1</span>&#125;,</span><br><span class="line">		&#123;name : <span class="string">"huangkai"</span>, id : <span class="number">2</span>&#125;,</span><br><span class="line">		&#123;name : <span class="string">"fangjie"</span>, id : <span class="number">3</span>&#125;</span><br><span class="line">	];</span><br><span class="line">	<span class="keyword">function</span> StudentListController(<span class="variable">$scope</span>)&#123;</span><br><span class="line">		<span class="variable">$scope</span>.students = students;</span><br><span class="line">		<span class="variable">$scope</span>.students.splice(<span class="number">1</span>,<span class="number">0</span>,&#123;name : <span class="string">"xuxiaofeng"</span>, id : <span class="number">4</span>&#125;);</span><br><span class="line">	&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="隐藏和显示">隐藏和显示</h3><p><strong>ng-show和ng-hide</strong></p>
<h3 id="css类与样式">css类与样式</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.menu-disabled-<span class="keyword">true</span>&#123;</span><br><span class="line">	color:gray;</span><br><span class="line">&#125;</span><br><span class="line">&lt;li <span class="keyword">class</span> = <span class="string">"menu-disabled-&#123;&#123;isDisabled&#125;&#125;"</span>&gt;&lt;/li&gt;</span><br></pre></td></tr></table></figure>
<p>以上的方法可以实现，但是同时在模板和js中使用的话就会无法维护。<br>在angular中，<strong>ng-class</strong>和<strong>ng-style</strong>指令。<br><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"HeaderConrtoller"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-class</span>=<span class="value">"&#123;error:isError, warning:isWarening&#125;"</span>&gt;</span></span><span class="expression">&#123;&#123;<span class="variable">messageText</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">button</span> <span class="attribute">ng-click</span> = "<span class="attribute">showError</span>()"&gt;</span>Error<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">button</span> <span class="attribute">ng-click</span> = "<span class="attribute">showWarning</span>()"&gt;</span>Warning<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="actionscript"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">HeaderController</span><span class="params">($scope)</span></span>&#123;</span><br><span class="line">		xxx;</span><br><span class="line">	&#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>###反思src和href属性<br><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">ng-src</span>=<span class="value">"http://hz2015.sinaapp.com/static/pictures/</span></span></span><span class="expression">&#123;&#123;<span class="variable">name</span>&#125;&#125;</span><span class="xml"><span class="tag"><span class="value">"</span> <span class="attribute">alt</span>=<span class="value">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">ng-href</span>=<span class="value">"http://hz2015.sinaapp.com"</span>&gt;</span><span class="tag">&lt;/<span class="title">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>###表达式<br>表示是可以充分的灵活性在模板、业务逻辑和数据之间建立联系，同时又可以避免业务逻辑渗透到模板中。</p>
<p>###区分UI和控制器的职责<br>控制器的职责</p>
<ul>
<li>为模板设置初始状态</li>
<li>通过$Scope对象把数据模型和函数暴露给视图。</li>
<li>监视模板其余部分的变化，并采取相应的动作。</li>
</ul>
<p>###利用$scope暴露模型数据<br>显性创建很常见了，下来来看简介的创建$scope属性的方法：</p>
<ul>
<li><p>表达式法：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">button</span> <span class="attribute">ng-click</span>=<span class="value">"count=5"</span>&gt;</span>press<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>表单输入项中使用ng-model。在表单项和指定的模板数据之间建立双向绑定关系。</p>
</li>
</ul>
<p>###使用$watch监控数据模型的变化<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$watch</span>(watchFn, watchAction, deepWatch);</span><br></pre></td></tr></table></figure></p>
<p>watchFn:是一个带有angular表达式或者函数的<strong>字符串</strong>。<br>watchAction:函数或者表达式，当watchFn变化的时候被调用。函数签名是<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span><span class="params">(newValue, oldValue, scope)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>deepWatch: 检查被监控的对象的<strong>每个属性</strong>是否发生了变化。</p>
<p>$watch函数会返回一个函数。可以使用这个返回值注销这个函数。</p>
<p>带折扣的购物车以及注意watch()中的性能注意事项见P30-P34。</p>
<p>###监控多个东西</p>
<ul>
<li><p>监控把这些属性链接起来之后的值</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$scope</span>.<span class="variable">$watch</span>(<span class="string">"things.a + things.b"</span>, doSomething);</span><br></pre></td></tr></table></figure>
</li>
<li><p>把他们放进一个数组或者对象中，然后给deepWatch参数设置成true</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$scope</span>.<span class="variable">$watch</span>(<span class="string">"things"</span>, doSomething, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="使用Module组织依赖关系">使用Module组织依赖关系</h2><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	<span class="keyword">function</span> ShoppingController(<span class="variable">$scope</span>, Items)&#123;</span><br><span class="line">		<span class="variable">$scope</span>.items = Items.query();</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>以上假设Items这个对象已经被定义成一个服务。<br>服务都是单例的对象。<br>angular.js内置很多服务：</p>
<ul>
<li>$location用来和浏览器的地址栏交互。</li>
<li>$route用来根据URL地址的变化切换视图。</li>
<li>$http用来和服务器交互。</li>
<li>自定义服务，可以在不同的控制器之间共享。</li>
</ul>
<p>模型对象的API来定义服务。</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">定义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">provider(name, Object OR constructor())</td>
<td style="text-align:left">返回服务的名称，如果是Object，则Object必须有一个$get的函数。如果是constructor(),则会返回服务实例对象。</td>
</tr>
<tr>
<td style="text-align:left">factory(name, $getFunction())</td>
<td style="text-align:left">返回服务实例。看成以上Object时候的情形。</td>
</tr>
<tr>
<td style="text-align:left">server(name, constructor())</td>
<td style="text-align:left">比较简单，看成最上面是constructor的情形</td>
</tr>
</tbody>
</table>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	<span class="keyword">function</span> ShoppingController(<span class="variable">$scope</span>, Items)&#123;</span><br><span class="line">		<span class="variable">$scope</span>.items = Items.query();</span><br><span class="line">	&#125;</span><br><span class="line">	//创建一个模型来支持视图</span><br><span class="line">	var shoppingModule = angular.module(<span class="string">"shoppingModule"</span>, []);</span><br><span class="line">	shoppingModule.factory(<span class="string">"Items"</span>, <span class="keyword">function</span>()&#123;</span><br><span class="line">		var items =&#123;&#125;;</span><br><span class="line">		items.query = function()&#123;</span><br><span class="line">          return [</span><br><span class="line">            &#123;title: <span class="string">'Paint pots'</span>, description: <span class="string">'Pots full of paint'</span>, price: <span class="number">3.95</span>&#125;,</span><br><span class="line">            &#123;title: <span class="string">'Polka dots'</span>, description: <span class="string">'Dots with polka'</span>, price: <span class="number">2.95</span>&#125;,</span><br><span class="line">            &#123;title: <span class="string">'Pebbles'</span>, description: <span class="string">'Just little rocks'</span>, price: <span class="number">6.95</span>&#125;</span><br><span class="line">          ];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="使用过滤器格式化数据">使用过滤器格式化数据</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="expansion">&#123;&#123;expression | filterName <span class="symbol">:</span> parameter1 <span class="symbol">:</span> ... parameterN&#125;&#125;</span>\</span><br><span class="line"><span class="expansion">&#123;&#123;<span class="number">12.9</span> | currency&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p>angular内置的过滤器还有：date, number, uppercase<br>同时也可以自定义过滤器。<br><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"HomeModule"</span> <span class="attribute">ng-controller</span>=<span class="value">"HomeController"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">h1</span>&gt;</span></span><span class="expression">&#123;&#123;<span class="variable">pageHeading</span> | <span class="variable">titleCase</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="actionscript"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">HomeController</span><span class="params">($scope)</span></span>&#123;</span><br><span class="line">		$scope.pageHeading = <span class="string">"hzhuang is a very nice man!"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> homeModule = angular.module(<span class="string">"HomeModule"</span>, []);</span><br><span class="line">	homeModule.filter(<span class="string">"titleCase"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">var</span> titleCaseFilter = <span class="function"><span class="keyword">function</span><span class="params">(input)</span></span>&#123;</span><br><span class="line">			<span class="keyword">var</span> words = input.split(<span class="string">" "</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ,len = words.length; i&lt; len; i++ )&#123;</span><br><span class="line">				words[i] = words[i].charAt(<span class="number">0</span>).toUpperCase() + words[i].slice(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">return</span> words.join(<span class="string">" "</span>);</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">return</span> titleCaseFilter;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>###使用路由和$location切换视图<br>利用路由服务来定义：对于浏览器所指向的特定URL，angular将会加载并显示一个模板，并实例化一个控制器来为模板提供内容。<br>调用$routeProvider服务上的函数来创建路由，把需要创建的路由当成一个配置快传给这些函数。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var someModule = angular.module(<span class="string">"someModule"</span>, []);</span><br><span class="line">someModule.config(<span class="keyword">function</span>(<span class="variable">$routeProvider</span>)&#123;</span><br><span class="line">	<span class="variable">$routeProvider</span>.</span><br><span class="line">	when(<span class="string">"url"</span>, &#123;controller:aController, templateURL:<span class="string">"/path/to/template"</span>&#125;).</span><br><span class="line">	when(...other mappings for you app).</span><br><span class="line">	...</span><br><span class="line">	otherwise(...what to do if no match);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>以创建邮件为例子。<br>在第一个加载的页面中仅仅创建一个布局模板，然后用这个模板来容纳各种视图。ng-view指令。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//index.html</span><br><span class="line"><span class="doctype">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span> <span class="attribute">ng-app</span>=<span class="value">"AMail"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">'controllers.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">h1</span>&gt;</span>A-Mail<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-view</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>用ng-repeat来遍历邮件列表，然后渲染到table中。<br><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">//list.html</span><br><span class="line"><span class="tag">&lt;<span class="title">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">td</span>&gt;</span><span class="tag">&lt;<span class="title">strong</span>&gt;</span>Sender<span class="tag">&lt;/<span class="title">strong</span>&gt;</span><span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">td</span>&gt;</span><span class="tag">&lt;<span class="title">strong</span>&gt;</span>Subject<span class="tag">&lt;/<span class="title">strong</span>&gt;</span><span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">td</span>&gt;</span><span class="tag">&lt;<span class="title">strong</span>&gt;</span>Date<span class="tag">&lt;/<span class="title">strong</span>&gt;</span><span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">tr</span> <span class="attribute">ng-repeat</span>=<span class="value">'message in messages'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">td</span>&gt;</span></span><span class="expression">&#123;&#123;<span class="variable">message.sender</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">td</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">ng-href</span>=<span class="value">'#/view/</span></span></span><span class="expression">&#123;&#123;<span class="variable">message.id</span>&#125;&#125;</span><span class="xml"><span class="tag"><span class="value">'</span>&gt;</span></span><span class="expression">&#123;&#123;<span class="variable">message.subject</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">td</span>&gt;</span></span><span class="expression">&#123;&#123;<span class="variable">message.date</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>想达到用户点击主题就会跳转到相应的邮件中，我们可以在URL和message.id中数据绑定。点击id=1的邮件就会被导航到/#/view/1。<br>创建一个模板，用来展示单个邮件对象上的属性。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&lt;strong&gt;<span class="constant">Subject</span><span class="symbol">:&lt;/strong&gt;</span> <span class="expansion">&#123;&#123;message.subject&#125;&#125;</span>&lt;<span class="regexp">/div&gt;</span><br><span class="line">&lt;div&gt;&lt;strong&gt;Sender:&lt;/strong</span>&gt; <span class="expansion">&#123;&#123;message.sender&#125;&#125;</span>&lt;<span class="regexp">/div&gt;</span><br><span class="line">&lt;div&gt;&lt;strong&gt;Date:&lt;/strong</span>&gt; <span class="expansion">&#123;&#123;message.date&#125;&#125;</span>&lt;<span class="regexp">/div&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;strong&gt;To:&lt;/strong</span>&gt;</span><br><span class="line">  &lt;span ng-repeat=<span class="string">'recipient in message.recipients'</span>&gt;<span class="expansion">&#123;&#123;recipient&#125;&#125;</span> &lt;<span class="regexp">/span&gt;</span><br><span class="line">&lt;/div</span>&gt;</span><br><span class="line">&lt;div&gt;<span class="expansion">&#123;&#123;message.message&#125;&#125;</span>&lt;<span class="regexp">/div&gt;</span><br><span class="line">&lt;a href='#/</span><span class="string">'&gt;Back to message list&lt;/a&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>就下来就可以配置URL<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	var aMailServices = angular.module(<span class="string">"AMail"</span>, []);</span><br><span class="line">	<span class="keyword">function</span> emailRouteConfig(<span class="variable">$routeProvider</span>)&#123;</span><br><span class="line">		<span class="variable">$routeProvider</span>.</span><br><span class="line">		when(<span class="string">"/"</span>, &#123;controller: ListController, templateUrl: <span class="string">"list.html"</span>&#125;).</span><br><span class="line">		when(<span class="string">"/view/:id"</span>,&#123;controller: DetailController, templateUrl: <span class="string">"detail.html"</span>&#125;).</span><br><span class="line">		otherwise(&#123;redirectTo: <span class="string">"/"</span>&#125;);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	aMailServices.config(emailRouteConfig);</span><br><span class="line">	<span class="keyword">function</span> ListController(<span class="variable">$scope</span>) &#123;</span><br><span class="line">	  <span class="variable">$scope</span>.messages = messages;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">function</span> DetailController(<span class="variable">$scope</span>, <span class="variable">$routeParams</span>) &#123;</span><br><span class="line">	  <span class="variable">$scope</span>.message = messages[<span class="variable">$routeParams</span>.id];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>可见，可以实现修改url的值实现切换视图。且实际上只有一个唯一真实的html页面。</p>
<p>###与服务器交互（$http）<br>$http提供一个可扩展的抽象方法列表，使得与服务器交互更加简单。支持http、Jsonp和cors方式。包含安全性支持。</p>
<p>如果查询“/products”时可以返回一个json数据。<br>则：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> shoppingController(<span class="variable">$scope</span>, <span class="variable">$http</span>)&#123;</span><br><span class="line">	<span class="variable">$http</span>.get(<span class="string">"/products"</span>).success(function(data, status, headers, config)&#123;</span><br><span class="line">		<span class="variable">$scope</span>.items = data;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后后ng-repeat指令就可以把这些json数据的信息渲染到视图中。</p>
<h3 id="使用指令修改DOM">使用指令修改DOM</h3><p>angular内置没有这个功能的指令，所以可以自定义指令。<br>通过模块对象的API来定义指令<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> appModule</span> = angular.module(<span class="string">"appModule"</span>, []);</span><br><span class="line">appModule.directive(<span class="string">"directiveName"</span>, directiveFunction);</span><br><span class="line"><span class="comment">//调用directive()即可。</span></span><br><span class="line"><span class="comment">//directiveFunction是一个工厂函数，用来定义指令的特性。</span></span><br></pre></td></tr></table></figure></p>
<p>实例：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> appModule = angular.module(<span class="string">"appModule"</span>, []);</span><br><span class="line">appModule.directive(<span class="string">"ngFocus"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">	link: <span class="function"><span class="keyword">function</span><span class="params">(scope, element, attrs, controller)</span></span>&#123;</span><br><span class="line">	element[<span class="number">0</span>].focus();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>###校验用户输入<br>angular中，必须所有的元素都是合法的情况下才会允许提交。<br>思路是这样的，在html5中使用required，以及输入的；类型比如number，email等，如果浏览器不支持h5的这些属性，angular会自动通过指令来实现。</p>
<p>在控制器中，可以使用$valid来获取表单的校验状态。所有合法时是true。<br>涉及到ng-disabled指令和$valid属性。<br><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">h1</span>&gt;</span>Sign Up<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">form</span> <span class="attribute">name</span>=<span class="value">'addUserForm'</span> <span class="attribute">ng-controller</span>=<span class="value">"AddUserController"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-show</span>=<span class="value">'message'</span>&gt;</span></span><span class="expression">&#123;&#123;<span class="variable">message</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span>&gt;</span>First name: <span class="tag">&lt;<span class="title">input</span> <span class="attribute">name</span>=<span class="value">'firstName'</span> <span class="attribute">ng-model</span>=<span class="value">'user.first'</span> <span class="attribute">required</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span>&gt;</span>Last name: <span class="tag">&lt;<span class="title">input</span> <span class="attribute">ng-model</span>=<span class="value">'user.last'</span> <span class="attribute">required</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span>&gt;</span>Email: <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">'email'</span> <span class="attribute">ng-model</span>=<span class="value">'user.email'</span> <span class="attribute">required</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span>&gt;</span>Age: <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">'number'</span></span><br><span class="line">                     <span class="attribute">ng-model</span>=<span class="value">'user.age'</span></span><br><span class="line">                     <span class="attribute">ng-maxlength</span>=<span class="value">'3'</span></span><br><span class="line">                     <span class="attribute">ng-min</span>=<span class="value">'1'</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">button</span> <span class="attribute">ng-click</span>=<span class="value">'addUser()'</span></span><br><span class="line">                 <span class="attribute">ng-disabled</span>=<span class="value">'!addUserForm.$valid'</span>&gt;</span>Submit<span class="tag">&lt;/<span class="title">button</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="actionscript"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">AddUserController</span><span class="params">($scope)</span> </span>&#123;</span><br><span class="line">    $scope.message = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    $scope.addUser = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO for the reader: actually save user to database...</span></span><br><span class="line">      $scope.message = <span class="string">'Thanks, '</span> + $scope.user.first + <span class="string">', we added you!'</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>几点说明：</p>
<ul>
<li>ng-disabled=’!addUserForm.$valid’来实现党所有的输入项合法就会恢复可点击。</li>
<li>.ng-invalid {border-color: red;}输入项还不是合法的时候的样式。（内置的）</li>
</ul>

      
    </div>

    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MVC/">MVC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端框架/">前端框架</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习笔记/">学习笔记</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    
<article id="post-designPattern" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/29/designPattern/" class="article-date">
  	<time datetime="2015-06-29T14:35:30.000Z" itemprop="datePublished">2015-06-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/29/designPattern/">javascript设计模式</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
<a href="https://unsplash.it/1568/500/?random" title="" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://unsplash.it/1568/500/?random" title=""></a>

      <div class="entry">
      
        <h1 id="javascript设计模式">javascript设计模式</h1><p>模式内容：</p>
<ul>
<li>Constructor构造器模式</li>
<li>Module模块模式</li>
<li>Revealing Module揭示模块模式</li>
<li>Singleton单例模式</li>
<li>Observer观察者模式</li>
<li>Mediator中介者模式</li>
<li>Prototype模式</li>
<li>Command模式</li>
<li>Facade外观模式</li>
<li>Factory工厂模式</li>
<li>Mixin混入模式</li>
<li>Decorator装饰者模式</li>
<li>Flyweight享元模式</li>
</ul>
      
    </div>

    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/06/29/designPattern/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    
<article id="post-codeRule-js" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/24/codeRule-js/" class="article-date">
  	<time datetime="2015-06-24T12:11:20.000Z" itemprop="datePublished">2015-06-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/24/codeRule-js/">前端代码规范-js</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
<a href="https://unsplash.it/1568/500/?random" title="" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://unsplash.it/1568/500/?random" title=""></a>

      <div class="entry">
      
        <h1 id="高质量的javascript">高质量的javascript</h1><h2 id="养成良好的编程习惯">养成良好的编程习惯</h2><ul>
<li>用匿名函数将脚本包起来，可以有效控制全局变量，避免冲突隐患。</li>
<li>使用命名空间</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="actionscript"></span><br><span class="line">	<span class="keyword">var</span> GLOBAL = &#123;&#125;;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="actionscript"></span><br><span class="line">	(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">var</span> a=<span class="number">123</span>,b=<span class="string">"hello world"</span>;</span><br><span class="line">		GLOBAL.A=&#123;&#125;;</span><br><span class="line">		GLOBAL.A.str2 = a;</span><br><span class="line">		GLOBAL.A.str = b;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
      
    </div>

    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/代码规范/">代码规范</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/06/24/codeRule-js/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    
<article id="post-codeRule" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/21/codeRule/" class="article-date">
  	<time datetime="2015-06-21T15:11:20.000Z" itemprop="datePublished">2015-06-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/21/codeRule/">前端代码规范-css</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
<a href="https://unsplash.it/1568/500/?random" title="" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://unsplash.it/1568/500/?random" title=""></a>

      <div class="entry">
      
        <h1 id="高质量的css">高质量的css</h1><ul>
<li>css的API使用(基础)</li>
<li>css的组织(base.css+ common.js + page.css)<br>三个css是层叠的关系。</li>
</ul>
<h3 id="base-css">base.css</h3><p>位于最底层，提供reset.css功能以及粒度最小的通用类——原子类。<strong>相对稳定，基本不需要维护</strong></p>
<h3 id="common-js">common.js</h3><p>位于中间层，是样式的模块化。<br>是要高度重用的模块，可以视为组件，放在common.css<br>不同的网站有不同的common层，但是同一个网站只应该有一个common层。</p>
<h3 id="page-css">page.css</h3><p>位于最高层，提供页面级的样式。</p>
      
    </div>

    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css/">css</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/代码规范/">代码规范</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/06/21/codeRule/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    
<article id="post-flex" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/21/flex/" class="article-date">
  	<time datetime="2015-06-21T01:30:30.000Z" itemprop="datePublished">2015-06-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/21/flex/">css3之伸缩盒布局(flex)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
<a href="https://unsplash.it/1568/500/?random" title="" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://unsplash.it/1568/500/?random" title=""></a>

      <div class="entry">
      
        <h1 id="1-flexbox的基本知识">1.flexbox的基本知识</h1><h2 id="布局模式">布局模式</h2><p>之前css2：</p>
<ul>
<li>块布局</li>
<li>行内布局</li>
<li>表格布局</li>
<li>定位布局</li>
</ul>
<p>现在：css3引入布局模式Flexbox布局；<br>主要思路：以最佳的方式填充可用空间。</p>
      
    </div>

    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css3/">css3</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/06/21/flex/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    
<article id="post-javascript-3th" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/19/javascript-3th/" class="article-date">
  	<time datetime="2015-06-19T13:37:00.000Z" itemprop="datePublished">2015-06-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/19/javascript-3th/">javascript高级程序设计第三版笔记（持续更新）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
<a href="https://unsplash.it/1568/500/?random" title="" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://unsplash.it/1568/500/?random" title=""></a>

      <div class="entry">
      
        <div id="toc" class="toc-article">
    <strong class="toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#第二章_javascript简介"><span class="toc-text">第二章 javascript简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第三章_基本概念"><span class="toc-text">第三章 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1_语法"><span class="toc-text">3.1 语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2_关键字和保留字"><span class="toc-text">3.2 关键字和保留字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4_数据类型"><span class="toc-text">3.4 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1_typeof操作符"><span class="toc-text">3.4.1 typeof操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2_Undefined类型"><span class="toc-text">3.4.2 Undefined类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3_null类型"><span class="toc-text">3.4.3 null类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-4_boolean类型"><span class="toc-text">3.4.4 boolean类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-5_number类型"><span class="toc-text">3.4.5 number类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-6_String类型"><span class="toc-text">3.4.6 String类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-7_Object类型"><span class="toc-text">3.4.7 Object类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5_操作符"><span class="toc-text">3.5 操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1_一元操作符"><span class="toc-text">3.5.1 一元操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-2_位操作符"><span class="toc-text">3.5.2 位操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-3_布尔操作符"><span class="toc-text">3.5.3 布尔操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-4_乘性操作符"><span class="toc-text">3.5.4 乘性操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-5_加性操作符"><span class="toc-text">3.5.5 加性操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-6_关系操作符"><span class="toc-text">3.5.6 关系操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-7_相等操作符"><span class="toc-text">3.5.7 相等操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-8_条件操作符"><span class="toc-text">3.5.8 条件操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-9_赋值操作符"><span class="toc-text">3.5.9 赋值操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-10_逗号操作符"><span class="toc-text">3.5.10 逗号操作符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6_语句"><span class="toc-text">3.6 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-2_do-while语句"><span class="toc-text">3.6.2 do-while语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-5_for-in_语句"><span class="toc-text">3.6.5 for-in 语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-6_label语句"><span class="toc-text">3.6.6 label语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-7_break和continue语句"><span class="toc-text">3.6.7 break和continue语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-8_with语句"><span class="toc-text">3.6.8 with语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7_函数"><span class="toc-text">3.7 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-2_没有重载"><span class="toc-text">3.7.2 没有重载</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第五章_引用类型"><span class="toc-text">第五章 引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2_Array类型"><span class="toc-text">5.2 Array类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1检测数组"><span class="toc-text">5.2.1检测数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1转换方法"><span class="toc-text">5.2.1转换方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3栈方法"><span class="toc-text">5.2.3栈方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-4_队列方法"><span class="toc-text">5.2.4 队列方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-5_重排序方法"><span class="toc-text">5.2.5 重排序方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-6_操作方法"><span class="toc-text">5.2.6 操作方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-7_位置方法"><span class="toc-text">5.2.7 位置方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-8_迭代方法"><span class="toc-text">5.2.8 迭代方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-9_缩小方法"><span class="toc-text">5.2.9 缩小方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3_Date类型"><span class="toc-text">5.3 Date类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1_理解对象"><span class="toc-text">6.1 理解对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1_属性类型"><span class="toc-text">6.1.1 属性类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2_定义多个属性"><span class="toc-text">6.1.2 定义多个属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-3_读取属性的特性"><span class="toc-text">6.1.3 读取属性的特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2_创建对象"><span class="toc-text">6.2 创建对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1_工厂模式"><span class="toc-text">6.2.1 工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2_构造函数模式"><span class="toc-text">6.2.2 构造函数模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-4_组合使用构造函数模式和原型模式"><span class="toc-text">6.2.4 组合使用构造函数模式和原型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-5_动态原型模式"><span class="toc-text">6.2.5 动态原型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-6_寄生构造函数模式"><span class="toc-text">6.2.6 寄生构造函数模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-7_稳妥构造函数模式"><span class="toc-text">6.2.7 稳妥构造函数模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3_继承"><span class="toc-text">6.3 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-1_原型链"><span class="toc-text">6.3.1 原型链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-2_借用构造函数"><span class="toc-text">6.3.2 借用构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-3_组合继承"><span class="toc-text">6.3.3 组合继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-4_原型式继承"><span class="toc-text">6.3.4 原型式继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-5_寄生式继承"><span class="toc-text">6.3.5 寄生式继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-6_寄生组合式继承"><span class="toc-text">6.3.6  寄生组合式继承</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第七章_函数表达式"><span class="toc-text">第七章 函数表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1_递归"><span class="toc-text">7.1 递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2_闭包"><span class="toc-text">7.2 闭包</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第八章_BOM"><span class="toc-text">第八章 BOM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1_window对象"><span class="toc-text">8.1 window对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-1_全局作用域"><span class="toc-text">8.1.1 全局作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-2_窗口关系及框架"><span class="toc-text">8.1.2 窗口关系及框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-3_窗口位置"><span class="toc-text">8.1.3 窗口位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-4_窗口大小"><span class="toc-text">8.1.4 窗口大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-5_导航和打开窗口"><span class="toc-text">8.1.5 导航和打开窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-6_间歇调用和超时调用"><span class="toc-text">8.1.6 间歇调用和超时调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-7_系统对话框"><span class="toc-text">8.1.7 系统对话框</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2_location对象"><span class="toc-text">8.2 location对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-1_查询字符串参数"><span class="toc-text">8.2.1 查询字符串参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3_navigator对象"><span class="toc-text">8.3 navigator对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-1_检测插件"><span class="toc-text">8.3.1 检测插件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5history对象"><span class="toc-text">8.5history对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1_节点层次"><span class="toc-text">10.1 节点层次</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-1_Node类型"><span class="toc-text">10.1.1 Node类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-5_Comment类型(8)"><span class="toc-text">10.1.5 Comment类型(8)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-7_DocumentType类型(x)"><span class="toc-text">10.1.7 DocumentType类型(x)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-8_DocumentFragment类型(11)"><span class="toc-text">10.1.8 DocumentFragment类型(11)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2_DOM操作技术"><span class="toc-text">11.2 DOM操作技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-1_动态脚本"><span class="toc-text">11.2.1 动态脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-2_动态样式"><span class="toc-text">10.2.2 动态样式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-3_操作表格"><span class="toc-text">10.2.3 操作表格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-4_使用NodeList"><span class="toc-text">10.2.4 使用NodeList</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1_选择符_API"><span class="toc-text">11.1 选择符 API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-1_querySelector()方法"><span class="toc-text">11.1.1 querySelector()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-2_querySelectorAll()"><span class="toc-text">11.1.2 querySelectorAll()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-3_matchesSelector()"><span class="toc-text">11.1.3 matchesSelector()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2_元素遍历"><span class="toc-text">11.2 元素遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3_HTML5"><span class="toc-text">11.3 HTML5</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-3_HTMLDocument的变化"><span class="toc-text">11.3.3 HTMLDocument的变化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-readyState属性"><span class="toc-text">1.readyState属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-4_字符集属性"><span class="toc-text">11.3.4 字符集属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-5_自定义数据属性"><span class="toc-text">11.3.5 自定义数据属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-6_插入标记"><span class="toc-text">11.3.6 插入标记</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-7_scrolltoView()方法。"><span class="toc-text">11.3.7 scrolltoView()方法。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-4专有扩展"><span class="toc-text">11.4专有扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-4_插入文本"><span class="toc-text">11.4.4 插入文本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-5_滚动"><span class="toc-text">11.4.5 滚动</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第12章_DOM2和DOM3"><span class="toc-text">第12章 DOM2和DOM3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1_DOM变化"><span class="toc-text">12.1 DOM变化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-1-1_针对XML命名空间的变化"><span class="toc-text">21.1.1 针对XML命名空间的变化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-1_requestAnimationFrame(_)"><span class="toc-text">25.1 requestAnimationFrame( )</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#早期动画循环"><span class="toc-text">早期动画循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-1-3_mozRequestAnimationFrame"><span class="toc-text">25.1.3 mozRequestAnimationFrame</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-2_Page_Visibility_API"><span class="toc-text">25.2 Page Visibility API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-3_Geolocation_API"><span class="toc-text">25.3 Geolocation API</span></a></li></ol></li></ol>
</div>

      
        <a id="more"></a>
<h1 id="第二章_javascript简介">第二章 javascript简介</h1><ul>
<li>netscape创建LiveScript脚本语言。搭java顺风车就改为javascript。</li>
<li>js三部分：ECMAScript，dom，bom</li>
<li>script标签的defer和async属性只针对外部文件，一般不用，没有这两者的时候，就会按照在页面中出现的位置先后执行的。</li>
<li>js文件放在html外部的优势：可维护性，可缓存，适应未来。</li>
<li>如果浏览器不支持javascript，那么可以用noscript标签来写出替代说明文字。</li>
</ul>
<hr>
<h1 id="第三章_基本概念">第三章 基本概念</h1><h2 id="3-1_语法">3.1 语法</h2><ul>
<li>区分大小写</li>
<li>标识符</li>
<li>注释<br>单行（//） 多行（/<em>  </em>/）</li>
<li>严格模式 use strict<br>javascript的一种不同的解析与执行模型。一些不确定的行为将得到处理以及某些不安全的操作会抛出错误。</li>
<li>语句</li>
</ul>
<h2 id="3-2_关键字和保留字">3.2 关键字和保留字</h2><p>全部关键字：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>，<span class="keyword">case</span>，catct，<span class="keyword">continue</span>，<span class="keyword">debugger</span>，<span class="keyword">default</span>，<span class="keyword">delete</span>，<span class="keyword">do</span>，<span class="keyword">else</span>，<span class="keyword">finally</span>，<span class="keyword">for</span>，<span class="keyword">function</span>，<span class="keyword">if</span>，<span class="keyword">in</span>，<span class="keyword">instanceof</span>，<span class="keyword">new</span>，<span class="keyword">return</span>，<span class="keyword">switch</span>，<span class="keyword">this</span>，<span class="keyword">throw</span>，<span class="keyword">try</span>，<span class="keyword">typeof</span>，<span class="keyword">var</span>，<span class="literal">void</span>，<span class="keyword">while</span>，<span class="keyword">with</span></span><br></pre></td></tr></table></figure></p>
<h2 id="3-4_数据类型">3.4 数据类型</h2><ul>
<li>五个基本的数据类型：<br>string,number,boolean,null,undefined</li>
<li>一个复杂类型：<br>object</li>
</ul>
<h3 id="3-4-1_typeof操作符">3.4.1 typeof操作符</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> huang = <span class="string">"hzhaung"</span>;</span><br><span class="line"><span class="keyword">var</span> zhuang=<span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(huang)); <span class="comment">//string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="number">95</span>)); <span class="comment">//number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="number">1</span> == <span class="number">2</span>)); <span class="comment">//booleam</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(a)); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(zhuang)); <span class="comment">//object    原因:null是被认为是一个空的对象指针</span></span><br></pre></td></tr></table></figure>
<h3 id="3-4-2_Undefined类型">3.4.2 Undefined类型</h3><p>未申明的变量以及为初始化的变量都是undefined。</p>
<h3 id="3-4-3_null类型">3.4.3 null类型</h3><p>null值表示一个空的对象指针。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> 返回<span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>注意的是一般设置变量为null是为了用这个变量来保存对象，故而要写出var xx=null。</p>
<h3 id="3-4-4_boolean类型">3.4.4 boolean类型</h3><ul>
<li>false，””，0+NAN，null，undefined都是false。换句话说就是其他的都是true了。</li>
<li>区别大小写。</li>
</ul>
<h3 id="3-4-5_number类型">3.4.5 number类型</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> num1</span> = <span class="number">070</span>; <span class="comment">//八进制</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> num2</span> = <span class="number">0xA</span>; <span class="comment">//十六进制</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> num3</span> = <span class="number">10</span>; <span class="comment">//十进制</span></span><br></pre></td></tr></table></figure>
<ul>
<li>NUMBER.MIN_VALUE或者NUMBER.MAX_VALUE超出就会自动转换成infinity，如果是负的就在前面加上-。</li>
</ul>
<p>ifFinity( ):判断数值是否在有限数值范围内，true表示在，false表示不在。</p>
<p>NaN(not a number)</p>
<ul>
<li>任意涉及NaN的操作都会返回NaN;</li>
<li>NaN与任何值都不相等，包含NaN本身。</li>
</ul>
<p>isNaN( ):接受参数后会将其转化成数值，不能转化的话就会返回true。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">"huang"</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">true</span>));  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>));  <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>数值转换:</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">作用对象</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Number( )</td>
<td style="text-align:left">可用于任何数据类型</td>
</tr>
<tr>
<td style="text-align:left">parseInt( )</td>
<td style="text-align:left">针对字符串</td>
</tr>
<tr>
<td style="text-align:left">parseFloat( )</td>
<td style="text-align:left">针对字符串</td>
</tr>
</tbody>
</table>
<p>Number的转换规则：</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">boolean</td>
<td style="text-align:left">false-0;true-1</td>
</tr>
<tr>
<td style="text-align:left">number</td>
<td style="text-align:left">简单的传入换个返回</td>
</tr>
<tr>
<td style="text-align:left">null</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">undefined</td>
<td style="text-align:left">NaN</td>
</tr>
<tr>
<td style="text-align:left">string</td>
<td style="text-align:left">“123”-123；“1.1”-1.1；“0xf”-15；“”-0；其他-NaN）</td>
</tr>
<tr>
<td style="text-align:left">object</td>
<td style="text-align:left">调用valueOf( ),然后依照前面的规则</td>
</tr>
<tr>
<td style="text-align:left">NaN</td>
<td style="text-align:left">调用toString( ),然后依照前面的规则</td>
</tr>
</tbody>
</table>
<p>parseInt( )示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"1234blue"</span>)); <span class="comment">//1234</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"0xA"</span>)); <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"22.5"</span>)); <span class="comment">//22</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseInt</span>(<span class="string">"10"</span>,<span class="number">2</span>); <span class="comment">//2</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">"10"</span>,<span class="number">8</span>); <span class="comment">//8</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">"10"</span>,<span class="number">10</span>); <span class="comment">//10</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">"10"</span>,<span class="number">16</span>); <span class="comment">//16</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3-4-6_String类型">3.4.6 String类型</h3><ul>
<li>toString( )除null和undefined,因为他们没有这个方法。一般是不用参数的，可以加一个参数来表示数值的基数。</li>
<li>String( )规则：null返回”null”,undefined返回“undefined”。（在不知道要转化的值是不是null或者undefined）</li>
</ul>
<h3 id="3-4-7_Object类型">3.4.7 Object类型</h3><p>一组数据和功能的集合。每个实例具有以下的属性和方法。对象是实例的基础。</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Constructor</td>
<td style="text-align:left">保存用于创建当前对象的函数，构造函数</td>
</tr>
<tr>
<td style="text-align:left">hasOwnproperty（propertyName）</td>
<td style="text-align:left">检查给定的属性在当前的实例中是否存在。<strong>不是</strong>在实例的原型中。</td>
</tr>
<tr>
<td style="text-align:left">isPrototypeof（object）</td>
<td style="text-align:left">检查对象是否是另一个对象的原型。</td>
</tr>
<tr>
<td style="text-align:left">propertyIsEnumerable</td>
<td style="text-align:left">检查是否可以用for-in来枚举。</td>
</tr>
<tr>
<td style="text-align:left">toLocaleString( )</td>
<td style="text-align:left">返回对象的字符串表示。</td>
</tr>
<tr>
<td style="text-align:left">toString( )</td>
<td style="text-align:left">返回对象的字符串表示。</td>
</tr>
<tr>
<td style="text-align:left">valueOf( )</td>
<td style="text-align:left">返回对象的字符串，数值或布尔值表示，通常和上个方法的返回值相同。</td>
</tr>
</tbody>
</table>
<h2 id="3-5_操作符">3.5 操作符</h2><p>在对对象使用操作符的时候，要调用valueOf( )或toString( )来获得可以操作的值。</p>
<h3 id="3-5-1_一元操作符">3.5.1 一元操作符</h3><p> 一元操作符：++，–，+，-。前置和后置的区别：前置的时候语句也改变。<br>递增和递减操作符的规则如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"1"</span>;</span><br><span class="line"><span class="keyword">var</span> str1 = <span class="string">"z"</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> f = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">	valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(++str); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(++str1);<span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(++b); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(++f);<span class="comment">//2.1</span></span><br><span class="line"><span class="built_in">console</span>.log(++o);<span class="comment">//0 </span></span><br><span class="line"><span class="comment">//如果是对象，则会先调用valueOf(),然后根据返回的值来确定加减之后的值。</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3-5-2_位操作符">3.5.2 位操作符</h3><p>32位，最后一个位表示符号位，0位正1为负。 正数就是常见的，对于负数则是以补码的形式储存（绝对值，反码，加1）。<br>但是输出负数时候这些操作都是隐藏的，输出的时候就是常见负数在前面加符号的形式。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var num = -<span class="number">18</span>;</span><br><span class="line">console.<span class="built_in">log</span>(num.toString(<span class="number">2</span>));<span class="comment">//"-10010"</span></span><br></pre></td></tr></table></figure></p>
<p>对于非数值使用位操作符，则先自动调用Number( )，然后再应用位操作。</p>
<ul>
<li><p>按位非( ~)<br>返回数值的反码:操作数的负数减1。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">num</span> = <span class="number">29</span>;</span><br><span class="line"><span class="keyword">var</span> num1 = ~ <span class="built_in">num</span>;</span><br><span class="line">console.log(num1); <span class="comment">//-26</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>按位与</p>
</li>
<li>按位或</li>
<li>按位异或</li>
<li>左移(&lt;&lt;)<br>移出的空位就以0补充。</li>
<li>右移</li>
</ul>
<h3 id="3-5-3_布尔操作符">3.5.3 布尔操作符</h3><p>1.逻辑非<br>对象-false；空-true；非空-false；0-true；任意非0-false；null-true；NaN-true；undefined-true</p>
<p>2.逻辑与<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">result</span> = <span class="literal">true</span> &amp;&amp; <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></p>
<p>3.逻辑或</p>
<h3 id="3-5-4_乘性操作符">3.5.4 乘性操作符</h3><p>乘法，除法和求模<br>如果有一个不是数值，则会先自动调用number（）之后再返回结果。<br>……</p>
<h3 id="3-5-5_加性操作符">3.5.5 加性操作符</h3><p><strong>加法</strong>特殊：</p>
<ul>
<li>两个字符串：就拼接起来。</li>
<li>只有一个字符串，则将另一个转换成字符串，然后拼接。</li>
<li>有一个是对象，数值或者布尔值，则调用toString( ),然后再拼接。</li>
<li>对于undefined和null,则调用String( )取到”undefined”和”null”。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="number">5</span>+<span class="string">"5"</span>); <span class="comment">//"55"</span></span><br></pre></td></tr></table></figure>
<p><strong>减法</strong>特殊：<br>不是数值的调用Number( )就OK啦。</p>
<h3 id="3-5-6_关系操作符">3.5.6 关系操作符</h3><p>规则：如示例代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="number">5</span> &gt; <span class="number">4</span>);<span class="comment">//true</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"h"</span> &gt; <span class="string">"z"</span>) <span class="comment">//false 转换为字符编码比较。</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="number">5</span>&lt;<span class="string">"2"</span>) <span class="comment">//false "2"自动转化成2</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3-5-7_相等操作符">3.5.7 相等操作符</h3><table>
<thead>
<tr>
<th style="text-align:left">数据类型</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">一个boolean</td>
<td style="text-align:left">先转化成数值然后再判断</td>
</tr>
<tr>
<td style="text-align:left">string+number</td>
<td style="text-align:left">string转化成数值先</td>
</tr>
<tr>
<td style="text-align:left">对象+非对象</td>
<td style="text-align:left">调用对象的valueOf( )方法，得到的值再比较</td>
</tr>
<tr>
<td style="text-align:left">null+undefined</td>
<td style="text-align:left">相等</td>
</tr>
<tr>
<td style="text-align:left">有NaN</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left">对象+对象</td>
<td style="text-align:left">比较是不是同一个人对象</td>
</tr>
</tbody>
</table>
<p>全等和不全等：</p>
<ul>
<li>===：未经转化的情况下相等才会返回true<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>   -----<span class="literal">true</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span> -----<span class="literal">false</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-5-8_条件操作符">3.5.8 条件操作符</h3><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">variable</span> = boolean<span class="number">_</span>expression ? true<span class="number">_</span><span class="keyword">value</span> : false<span class="number">_</span><span class="keyword">value</span> ;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-9_赋值操作符">3.5.9 赋值操作符</h3><h3 id="3-5-10_逗号操作符">3.5.10 逗号操作符</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var <span class="label">num1</span>,<span class="label">num2</span>,<span class="label">num3</span>;</span><br></pre></td></tr></table></figure>
<h2 id="3-6_语句">3.6 语句</h2><p>整理不常用的，if，for就整理啦。</p>
<h3 id="3-6-2_do-while语句">3.6.2 do-while语句</h3><p>只有在循环体重的代码执行之后，才会测试出口条件。即，循环体内的代码至少会执行一次。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	i += <span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">while</span>(i &lt; <span class="number">10</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="3-6-5_for-in_语句">3.6.5 for-in 语句</h3><p>一种准确的迭代语句，可以用来枚举对象的属性。</p>
<h3 id="3-6-6_label语句">3.6.6 label语句</h3><p>标签 labe：statement。这个标签可以通过break或者continue来引用，一般与for语句配合使用。</p>
<h3 id="3-6-7_break和continue语句">3.6.7 break和continue语句</h3><ul>
<li>break会立即退出循环</li>
<li>continue也会立即退出循环，但是退出后会从循环的顶部继续执行。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var no = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(var i= <span class="number">1</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(i % <span class="number">5</span> == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">continue</span>;  </span><br><span class="line">	&#125;</span><br><span class="line">	no++ ;</span><br><span class="line">&#125;</span><br><span class="line">console.<span class="built_in">log</span>(no);<span class="comment">//8</span></span><br><span class="line"></span><br><span class="line">var no = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(var i= <span class="number">1</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(i % <span class="number">5</span> == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">break</span>;  </span><br><span class="line">	&#125;</span><br><span class="line">	no++ ;</span><br><span class="line">&#125;</span><br><span class="line">console.<span class="built_in">log</span>(no);<span class="comment">//4</span></span><br></pre></td></tr></table></figure>
<p>结合label可以说明是退出的那个循环。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var num = <span class="number">0</span>;</span><br><span class="line">outermost:</span><br><span class="line"><span class="keyword">for</span>(var i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(var j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i == <span class="number">5</span> &amp;&amp; j==<span class="number">5</span>)&#123;</span><br><span class="line">			<span class="keyword">break</span> outermost;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-6-8_with语句">3.6.8 with语句</h3><p>将代码的作用域设置到一个特定的对象中。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">with(location)&#123;</span><br><span class="line">	<span class="variable"><span class="keyword">var</span> gs</span> = search.substring(<span class="number">1</span>);    <span class="comment">//等价于var gs = location.search.substring(1);</span></span><br><span class="line">	<span class="variable"><span class="keyword">var</span> hostName</span> = hostname;</span><br><span class="line">	<span class="variable"><span class="keyword">var</span> url</span> = href;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-7_函数">3.7 函数</h2><p>好处：封装，任意时刻调用。</p>
<p>ECMAScript中函数可以通过return语句返回值。执行return后就会停止。如果return语句不带返回的值，则会默认返回undefined。</p>
<p>注：eval和arguments不可以定义为变量。</p>
<p>函数的参数：</p>
<ul>
<li>函数内部的参数是一个数组，arguments对象。   类似array，arguments[0]是合法的，而且也有length属性。故： 在定义函数的时候参数是非必须的，在调用的时候加上参数也不会出问题。这是区别其他语言的。</li>
<li>arguments对象可以和命名的参数一起使用。但是两者的内存空间是不一样的。</li>
</ul>
<h3 id="3-7-2_没有重载">3.7.2 没有重载</h3><p>没有重载：由于js函数的特点，则是无法实现重载的，如果存在两个则后取。</p>
<h1 id="第五章_引用类型">第五章 引用类型</h1><h2 id="5-2_Array类型">5.2 Array类型</h2><p>js的数组可以保存任何类型的数据，也可以自动增长。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建方法一：Array构造函数</span></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="comment">//创建长度是20</span></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建方法二：数组字面两表示法。</span></span><br><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"yellow"</span>, <span class="string">"white"</span>];</span><br></pre></td></tr></table></figure></p>
<p>数组不仅仅是可读的。如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];  </span><br><span class="line">colors.length = <span class="number">2</span>;</span><br><span class="line">alert(colors[<span class="number">2</span>]);        <span class="comment">//undefined  第三项移除了</span></span><br></pre></td></tr></table></figure></p>
<h3 id="5-2-1检测数组">5.2.1检测数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">	xxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这种方法是有问题：</p>
<ul>
<li>假定单一的全局执行环境，如果有多个框架，则就会有多个全局执行环境。从而存在多个不同版本的构造函数。</li>
</ul>
<p>改进：<figure class="highlight"><figcaption><span>)```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">```&#10;if(Array.isArray(value))&#123;&#10;&#9;xxx;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="5-2-1转换方法">5.2.1转换方法</h3><table>
<thead>
<tr>
<th style="text-align:left">转换方法</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">toLocaleString( )</td>
<td style="text-align:left">类似toString( )</td>
</tr>
<tr>
<td style="text-align:left">toString( )</td>
<td style="text-align:left">会返回由数组中每个值得字符串形式凭借而成的一个以逗号分隔的字符串。</td>
</tr>
<tr>
<td style="text-align:left">valueOf( )</td>
<td style="text-align:left">返回的还是数值</td>
</tr>
</tbody>
</table>
<p>eg：<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var colors=[<span class="string">"red"</span>,<span class="string">"blcak"</span>,<span class="string">"white"</span>]</span><br><span class="line">console.<span class="keyword">log</span>(colors.valueOf());//[<span class="string">"red"</span>, <span class="string">"blcak"</span>, <span class="string">"white"</span>]</span><br><span class="line">console.<span class="keyword">log</span>(colors.<span class="keyword">to</span>String());//red,blcak,white</span><br></pre></td></tr></table></figure></p>
<p>join( ):方法讲数组按照（）内的参数连接起来。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> colors</span>=[<span class="string">"red"</span>,<span class="string">"blcak"</span>,<span class="string">"white"</span>]</span><br><span class="line"><span class="variable"><span class="keyword">var</span> test_one</span> = colors.valueOf().join();</span><br><span class="line"><span class="variable"><span class="keyword">var</span> test_two</span> = colors.valueOf().join(<span class="string">"-"</span>);</span><br><span class="line">console.log(test_one);<span class="comment">//red,blcak,white</span></span><br><span class="line">console.log(test_two);<span class="comment">//red-blcak-white</span></span><br></pre></td></tr></table></figure></p>
<h3 id="5-2-3栈方法">5.2.3栈方法</h3><p>数组可以表现的像栈一样，栈是一种可以限制插入和删除项的数据结构。后进先出。</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">push( )</td>
<td style="text-align:left">将参数里面的对象逐个添加到数组中，并返回数组修改后的长度值。</td>
</tr>
<tr>
<td style="text-align:left">pop( )</td>
<td style="text-align:left">与push的作用相反,但是返回值是数组的<strong>最后一项</strong></td>
</tr>
</tbody>
</table>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">var</span> colors=[<span class="string">"red"</span>,<span class="string">"blcak"</span>,<span class="string">"white"</span>]</span><br><span class="line"> console.<span class="function"><span class="title">log</span><span class="params">(colors.push(<span class="string">"huang"</span> , <span class="string">"zhuang"</span>)</span></span>)<span class="comment">//5;</span></span><br></pre></td></tr></table></figure>
<h3 id="5-2-4_队列方法">5.2.4 队列方法</h3><p>队列的访问规则是“先进先出”，表现在队列的末端添加项，在队列的前端移除项。</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">shift( )</td>
<td style="text-align:left">移除数组中的第一项，并返回该项</td>
</tr>
<tr>
<td style="text-align:left">unshift( )</td>
<td style="text-align:left">与shift的作用相反,可以在数组的前端添加任意个项并返回数组的长度。</td>
</tr>
</tbody>
</table>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟队列的组合</span></span><br><span class="line"><span class="function"><span class="title">push</span><span class="params">( )</span></span> + <span class="function"><span class="title">shift</span><span class="params">( )</span></span> </span><br><span class="line"><span class="function"><span class="title">unshift</span><span class="params">( )</span></span> + <span class="function"><span class="title">pop</span><span class="params">( )</span></span></span><br></pre></td></tr></table></figure>
<h3 id="5-2-5_重排序方法">5.2.5 重排序方法</h3><table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">reverse( )</td>
<td style="text-align:left">反转数组项的排序</td>
</tr>
<tr>
<td style="text-align:left">sort( )</td>
<td style="text-align:left">按照升序的方法排列数组项，会调用每个项的toString( )转型方法，比较的是<strong>字符串</strong></td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort( );</span><br><span class="line">console.<span class="built_in">log</span>(values);<span class="comment">//[0, 1, 10, 15, 5]因为是比较的字符串，所以5在最后。</span></span><br></pre></td></tr></table></figure>
<p>可见以上的sort( ）的方法不够完美。<br>sort( )可以接受<em>一个比较函数</em>作为参数来完善不足。<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> compare(<span class="keyword">value</span><span class="number">1</span>, <span class="keyword">value</span><span class="number">2</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">value</span><span class="number">1</span> - <span class="keyword">value</span><span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">values.sort(compare);</span><br><span class="line">console.log(values);<span class="comment">//[0, 1, 5, 10, 15]</span></span><br></pre></td></tr></table></figure></p>
<p>可见，完美解决，达到排序的效果。</p>
<h3 id="5-2-6_操作方法">5.2.6 操作方法</h3><table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">concat( )</td>
<td style="text-align:left">基于当前数组中的所有项创建一个新的数组（副本），然后将接受到的参数添加到这个副本的末尾。</td>
</tr>
<tr>
<td style="text-align:left">slice( )</td>
<td style="text-align:left">基于当前的数组中的一个或者多个创建一个新的数组</td>
</tr>
<tr>
<td style="text-align:left">splice( )</td>
<td style="text-align:left">向数组的中部插入项。</td>
</tr>
</tbody>
</table>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// <span class="atom">concat</span></span><br><span class="line"><span class="atom">var</span> <span class="atom">colors</span> = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"yellow"</span>];</span><br><span class="line"><span class="atom">var</span> <span class="atom">color_new</span> = <span class="atom">colors</span>.<span class="atom">concat</span>(<span class="string">"huang"</span>,[<span class="string">"zhuang"</span>,<span class="string">"hz"</span>]);</span><br><span class="line"><span class="atom">console</span>.<span class="atom">log</span>(<span class="atom">color_new</span>);//[<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"yellow"</span>, <span class="string">"huang"</span>, <span class="string">"zhuang"</span>, <span class="string">"hz"</span>]</span><br><span class="line"></span><br><span class="line">// <span class="atom">slice</span></span><br><span class="line">// 接受一个或者两个参数指定位置开始和到当前数组末尾的所有项。不会影响原始数组。</span><br><span class="line"><span class="atom">var</span> <span class="atom">colors</span> = [<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>,<span class="string">"yellow"</span>,<span class="string">"purple"</span>];</span><br><span class="line"><span class="atom">var</span> <span class="atom">colors2</span> = <span class="atom">colors</span>.<span class="atom">slice</span>(<span class="number">1</span>);</span><br><span class="line"><span class="atom">console</span>.<span class="atom">log</span>(<span class="atom">colors2</span>);//[<span class="string">"green"</span>, <span class="string">"blue"</span>, <span class="string">"yellow"</span>, <span class="string">"purple"</span>]</span><br><span class="line"><span class="atom">var</span> <span class="atom">colors3</span> = <span class="atom">colors</span>.<span class="atom">slice</span>(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line"><span class="atom">console</span>.<span class="atom">log</span>(<span class="atom">colors3</span>);//[<span class="string">"green"</span>, <span class="string">"blue"</span>, <span class="string">"yellow"</span>]</span><br></pre></td></tr></table></figure>
<p>splice( )详解：<br>1.删除<br>可以删除任意数量的项，指定两个参数：要删除的第一项的位置和要删除的项数。会返回删除的项。返回的是一个数组。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var colors = [<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>,<span class="string">"yellow"</span>,<span class="string">"purple"</span>];</span><br><span class="line">var <span class="built_in">remove</span> = colors.splice(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">console.<span class="built_in">log</span>(colors);//[<span class="string">"blue"</span>, <span class="string">"yellow"</span>, <span class="string">"purple"</span>]</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">remove</span>);//<span class="string">"red"</span>, <span class="string">"green"</span>]</span><br></pre></td></tr></table></figure></p>
<p>2.插入<br>可以添加任意数量的项，提供3个参数，起始位置，0和要插入的项。<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var removed = colors.<span class="keyword">splice</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="string">"huang"</span>,<span class="string">"zhuang"</span>);</span><br><span class="line">console.<span class="keyword">log</span>(colors);<span class="regexp">//</span>[<span class="string">"blue"</span>, <span class="string">"huang"</span>, <span class="string">"zhuang"</span>, <span class="string">"yellow"</span>, <span class="string">"purple"</span>]</span><br><span class="line">console.<span class="keyword">log</span>(removed);<span class="regexp">//</span>[ ]</span><br></pre></td></tr></table></figure></p>
<p>3.替换<br>可以在指定的地方出入任意数量的项，同事删除任意数量的项。<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var removed = colors.<span class="keyword">splice</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"huang"</span>,<span class="string">"zhuang"</span>);</span><br><span class="line">console.<span class="keyword">log</span>(colors);<span class="regexp">//</span>[<span class="string">"blue"</span>, <span class="string">"huang"</span>, <span class="string">"zhuang"</span>, <span class="string">"zhuang"</span>, <span class="string">"yellow"</span>, <span class="string">"purple"</span>]</span><br><span class="line">console.<span class="keyword">log</span>(removed);<span class="regexp">//</span>[<span class="string">"huang"</span>]</span><br></pre></td></tr></table></figure></p>
<p>发现：</p>
<ul>
<li>splice( )始终会返回一个数组。</li>
<li>返回的数组包含从原始数组中删除的项，如果没有删除过，就会返回一个空数组。</li>
</ul>
<h3 id="5-2-7_位置方法">5.2.7 位置方法</h3><table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">indexOf( )</td>
<td style="text-align:left">返回项在数组中的位置</td>
</tr>
<tr>
<td style="text-align:left">lastIndexOf( )</td>
<td style="text-align:left">同上</td>
</tr>
</tbody>
</table>
<p>接受两个参数：第一个是要查找的项，第二个参数表示的是表示起点位置的索引。</p>
<h3 id="5-2-8_迭代方法">5.2.8 迭代方法</h3><table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">every( )</td>
<td style="text-align:left">对数组的每一项运行给定函数，全部是true就会返回true</td>
</tr>
<tr>
<td style="text-align:left">filter( )</td>
<td style="text-align:left">对数组的每一项运行给点函数，返回改函数会返回<strong>true</strong>的项组成的数组</td>
</tr>
<tr>
<td style="text-align:left">foeEach( )</td>
<td style="text-align:left">对数组的每一项运行给点函数,无返回值</td>
</tr>
<tr>
<td style="text-align:left">map( )</td>
<td style="text-align:left">对数组的每一项运行给点函数,返回每次调用函数的结果组成的数组</td>
</tr>
<tr>
<td style="text-align:left">some( )</td>
<td style="text-align:left">对数组的每一项运行给点函数,如果该函数给任一项返回true，则就会返回true</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//filter</span></span><br><span class="line">var numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line">var filterResult = numbers.filter(function(item)&#123;</span><br><span class="line">	<span class="keyword">return</span> (item &gt;<span class="number">2</span>);<span class="comment">//[3, 4, 5, 4, 3]</span></span><br><span class="line">&#125;);</span><br><span class="line">console.<span class="built_in">log</span>(filterResult);</span><br><span class="line"></span><br><span class="line"><span class="comment">//map</span></span><br><span class="line">var numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line">var mapResult = numbers.<span class="built_in">map</span>(function(item)&#123;</span><br><span class="line">	<span class="keyword">return</span> item*<span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line">console.<span class="built_in">log</span>(mapResult);<span class="comment">//[2, 4, 6, 8, 10, 8, 6, 4, 2]</span></span><br></pre></td></tr></table></figure>
<h3 id="5-2-9_缩小方法">5.2.9 缩小方法</h3><table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">reduce( )</td>
<td style="text-align:left">迭代数组的所有项，然后构建一个最终返回的值，从第一项开始</td>
</tr>
<tr>
<td style="text-align:left">reduceRight( )</td>
<td style="text-align:left">迭代数组的所有项，然后构建一个最终返回的值，从最后一项开始</td>
</tr>
</tbody>
</table>
<p>作为参数的函数接受4个参数：前一个值，当前值，项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var values =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">var sum = values.reduce(function(prev, cur, index, <span class="built_in">array</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> prev+cur;</span><br><span class="line">&#125;);</span><br><span class="line">console.<span class="built_in">log</span>(sum);<span class="comment">//15</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="5-3_Date类型">5.3 Date类型</h2><p>#第六章 面向对象的程序设计<br>内容：</p>
<ul>
<li>理解对象属性</li>
<li>理解并创建对象</li>
<li>理解继承</li>
</ul>
<h2 id="6-1_理解对象">6.1 理解对象</h2><h3 id="6-1-1_属性类型">6.1.1 属性类型</h3><p>内部才有的特性，用[[…]]来表示的。<br>1.数据属性</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">[[Configurable]]</td>
<td style="text-align:left">能否delete删除属性从而重新定义、能否修改属性的特性、能否把属性修改为访问器属性。</td>
</tr>
<tr>
<td style="text-align:left">[[Enumerable]]</td>
<td style="text-align:left">能否通过for-in枚举。默认是true</td>
</tr>
<tr>
<td style="text-align:left">[[Eritable]]</td>
<td style="text-align:left">能否修改属性的值</td>
</tr>
<tr>
<td style="text-align:left">[[Value]]</td>
<td style="text-align:left">包含这个属性的数据值</td>
</tr>
</tbody>
</table>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="actionscript"></span><br><span class="line">	<span class="keyword">var</span> person = &#123;</span><br><span class="line">		name:<span class="string">"HuangZhuang"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如上所示：创建一个对象，它的默认内部属性前三个都是true,然后[[value]]被设置成了一个特定的值HuangZhuang。对象创建name属性，[[Value]]被设置了，在对name属性值得任何时候的修改都会反映在这个位置。</p>
<p>修改特性的默认值，只能调用：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.<span class="function"><span class="title">defineProperty</span><span class="params">(属性所在对象，<span class="string">"属性名字"</span>，<span class="string">"一个描述符对象"</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>如果要修改，则：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">	writable: <span class="literal">false</span>,</span><br><span class="line">	value: <span class="string">"hz"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//hz</span></span><br><span class="line">person.name= <span class="string">"hh"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//hz</span></span><br></pre></td></tr></table></figure></p>
<p>有一点注意：就是当Configurable是false时，其他三个的特性是要受到限制的，而且设定Object.defineProperty后，这四个特性均是默认设定成false的。</p>
<p>2.访问器属性<br>访问器属性不包含数组，但是包含一对getter和setter函数。</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">[[Configurable]]</td>
<td style="text-align:left">能否delete删除属性从而重新定义、能否修改属性的特性、能否把属性修改为访问器属性。</td>
</tr>
<tr>
<td style="text-align:left">[[Enumerable]]</td>
<td style="text-align:left">能否通过for-in枚举。默认是true</td>
</tr>
<tr>
<td style="text-align:left">[[Get]]</td>
<td style="text-align:left">读取属性时调用的函数</td>
</tr>
<tr>
<td style="text-align:left">[[Set]]</td>
<td style="text-align:left">写入属性时调用的函数</td>
</tr>
</tbody>
</table>
<p>访问器属性不可以直接定义，必须通过Object.defineProperty( )来定义。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">	_year : <span class="number">2004</span>,</span><br><span class="line">	edition: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line">Object.defineProperty(book, <span class="string">"year"</span>,&#123;</span><br><span class="line">	<span class="keyword">get</span>: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="keyword">set</span>: <span class="function"><span class="keyword">function</span><span class="params">(newValue)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(newValue &gt; <span class="number">2004</span>)&#123;</span><br><span class="line">			<span class="keyword">this</span>._year = newValue;</span><br><span class="line">			<span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line">alert(book.edition); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>下划线表示只能通过对象方法访问的属性。</p>
<h3 id="6-1-2_定义多个属性">6.1.2 定义多个属性</h3><p>Object.defineProperties(第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应)</p>
<h3 id="6-1-3_读取属性的特性">6.1.3 读取属性的特性</h3><p>一个函数Object.getOwnPropertyDescriptor( )针对属性是数据类型还是访问器类型返回出内部属性的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">"year"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>
<h2 id="6-2_创建对象">6.2 创建对象</h2><p>Object构造函数或对象字面量都可以创建单个对象，但是这种方式是有明显的缺点的：使用同一个接口创建很多对象，会产生大量的额重复代码。</p>
<h3 id="6-2-1_工厂模式">6.2.1 工厂模式</h3><p>用函数来封装以特定的接口创建对象的细节。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">	o.name = name;</span><br><span class="line">	o.age = age;</span><br><span class="line">	o.job = job;</span><br><span class="line">	o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o1 = createPerson(<span class="string">"hz"</span>, <span class="number">25</span>, <span class="string">'IT'</span>);</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>但是却没有解决对象识别的问题，即怎样知道一个对象的类型。</p>
<h3 id="6-2-2_构造函数模式">6.2.2 构造函数模式</h3><p>特点：</p>
<ul>
<li>没有显示的创建对象</li>
<li>直接将属性和方法赋值给this对象</li>
<li>没有return语句</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">this</span>.job = job;</span><br><span class="line">	<span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Person1 = <span class="keyword">new</span> Person(<span class="string">"hz"</span>, <span class="number">25</span>, <span class="string">"IT"</span>);</span><br></pre></td></tr></table></figure>
<p>构造函数始终都应该以一个大写字母开头，非构造函数才是用小写字母开头。</p>
<p>以上的例子中，要创建一个Person的新实例，要使用new操作符。经理四个步骤：</p>
<ul>
<li>1创建一个新对象。</li>
<li>2将构造函数打的作用域赋值给新对象，this就会指向新对象。</li>
<li>3执行构造函数中的代码。</li>
<li>4返回新对象。</li>
</ul>
<p>Person创建的实例，都有一个指向Person的Constructor属性。<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Person1.constructor == Person ); <span class="regexp">//</span><span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>构造函数与其他函数的唯一区别就是调用方式。new 操作符来调用函数就是构造函数，如果没有就和普通函数没有区别的。<br> <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为构造函数使用</span></span><br><span class="line"> <span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"hz"</span>, <span class="number">25</span>, <span class="string">"IT"</span>);</span><br><span class="line"> person.sayName();<span class="comment">//hz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//作为普通函数使用</span></span><br><span class="line">Person(<span class="string">"hz"</span>, <span class="number">25</span>, <span class="string">"IT"</span>);<span class="comment">//添加到window对象</span></span><br><span class="line"><span class="built_in">window</span>.sayName();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在另一个对象中使用</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">Person.call(o, <span class="string">"hz"</span>, <span class="number">25</span>, <span class="string">"IT"</span>); <span class="comment">//在o对象的特殊作用域中调用，o就拥有了所有属性和方法。</span></span><br><span class="line">o.sayName();</span><br></pre></td></tr></table></figure></p>
<p>构造函数的问题就是每个<strong>方法</strong>都要在每个实例上重新创建一遍。就是说不同实例上的同名函数实际上是不一样的。如果把这些方法通过全局作用域的函数调出来可以解决，但是当需要很多方法时，<em>封装性太差</em>。解决方法：原型模式。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var Person1 = <span class="keyword">new</span> Person(<span class="string">"hz"</span>, <span class="number">25</span>, <span class="string">"IT"</span>);</span><br><span class="line">var Person2 = <span class="keyword">new</span> Person(<span class="string">"hz"</span>, <span class="number">25</span>, <span class="string">"IT"</span>);</span><br><span class="line">console.<span class="built_in">log</span>(Person1.sayName == Person2.sayName); <span class="comment">//false</span></span><br></pre></td></tr></table></figure></p>
<p>1.理解原型对象<br>任何时候创建新函数，就会创建一个prototype属性，这个属性指向函数的原型对象。默认情况下，原型对象会自动获得一个constructor属性，这个属性包含一个<em>指向prototype属性所在函数的指针</em>。</p>
<p>虽然没有办法访问到[[prototype]],但是通过isPrototypeOf( )方法可以确定对象之间是否存在这种关系。如果[[prototype]]指向调用isPrototypeOf( )方法的对象，就会返回true。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(person1)); <span class="regexp">//</span><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>而ECMAScript5新增加的一个方法Object.getPrototypeOf( )返回的对象实际就是这个对象的原型。Object.getPrototypeOf( )很方便的取得一个对象的原型。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person1) == Person.prototype); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>几点说明：</p>
<ul>
<li>当代码读到属性时候，就会进行一次搜索，先从实例开始，如果没有搜到，则就会继续搜索指针指向的原型。</li>
<li>实例中重新定义新的属性和方法<em>不会改变原型中的属性和方法</em>，但是在调用该实例的时候会<em>屏蔽</em>原型的。</li>
<li>delete删除操作符可以完全删除实例属性。从而可以重新访问原型中的属性。</li>
<li>hasOwnPrototype( )检测一个属性是否存在实例中，还是存在原型中。这个方法是继承过来的，只有在实例设定属性或者方法的时候才会返回true；</li>
</ul>
<p>2.原型与in操作符</p>
<ul>
<li>单独使用in的时候，会在对象能够访问给定属性时返回true，实例和原型均可。<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person1); <span class="regexp">//</span><span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>通过hasOwnPrototype( )和in结合就可以封装一个检测属性是实例还是原型中的函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypeProperty</span>(<span class="params">object, name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !<span class="built_in">Object</span>.hasOwnProperty(name) &amp;&amp; (name <span class="keyword">in</span> object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>原理：只要in操作符返回true而且.hasOwnProperty( )返回false就可以判断属性是存在原型中的。</p>
<ul>
<li>for-in循环，返回的是所有能够通过对象访问的，可枚举的属性。包括在实例中的属性以及原型中的属性。屏蔽了原型中不可枚举属性的实例属性也会返回。<br>Object.keys()方法可以返回所有可枚举的实例属性。参数如果是xxx.prototype则返回原型课枚举的属性。如果对于实例调用则只会返回实例的属性和方法，不会返回原型的。<br>如果要得到所有属性和方法，不管是不是可枚举，则使用getOwnPrototypeNames()<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">keys</span> = Object.<span class="keyword">keys</span>(Person.<span class="keyword">prototype</span>);</span><br><span class="line">console.<span class="keyword">log</span>(<span class="keyword">keys</span>);<span class="regexp">//</span>[<span class="string">"name"</span>, <span class="string">"age"</span>, <span class="string">"job"</span>, <span class="string">"sayName"</span>];</span><br><span class="line">var key = Object.getOwnPropertyNames(Person.<span class="keyword">prototype</span>);</span><br><span class="line">console.<span class="keyword">log</span>(key);<span class="regexp">//</span>[<span class="string">"constructor"</span>, <span class="string">"name"</span>, <span class="string">"age"</span>, <span class="string">"job"</span>, <span class="string">"sayName"</span>];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>3.更简单的原型方法<br>为减少不必要的代码书写，可以使用如下的方法：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">        <span class="constructor"><span class="keyword">constructor</span> ： Person，//一般没有，是为了重新设置<span class="keyword">constructor</span>才用设置，但是会带来问题。</span><br><span class="line">	name : "hzhuang",</span><br><span class="line">	age : 25,</span><br><span class="line">	job : "IT",</span><br><span class="line">	sayName : function()</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上，Person.prototype设置成等于一个以对象字符量形式创建的新对象。但是值得注意的是此时constructor不再指向Person。此时的语法是完全重写了prototype对象，所以constructor属性就指向l构造函数Object，不再是Person了。如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">friend</span> = <span class="keyword">new</span> Person();</span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">friend</span>.constructor == Person);<span class="comment">//false</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">friend</span>.constructor == Object);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>如果想重新设定回去(让friend.constructor == Person是true)，那么就要在这个对象字面量里面添加一组condtructor的键值对。见3开始的例子。但是会带来问题，会让constructor属性变成可枚举的。</p>
<p>在兼容ECMAScript5的引擎中，可以用Object.definePeoperty来解决这个问题。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">Object</span><span class="class">.defineProperty</span>(Person.prototype, <span class="string">"constructor"</span>, &#123;</span><br><span class="line">	<span class="attribute">enumerable </span>: false,</span><br><span class="line">	<span class="attribute">value </span>: Person</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>4.原型的动态性<br>对原型对象所做的任何修改都可以立即在实例上反应出来。即使是先创建实例然后修改原型。<br>但是如果是重写原型，情况就大不一样了。调用构造函数时会为实例添加一个执行最初原型的[[prototype]]指针，而把原型修改成另一个对象就等于切断了构造函数与最初原型的联系。实例中的指针只执行原型，不指向构造函数。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="constructor"><span class="keyword">constructor</span> : Person,</span><br><span class="line">	name : "hzhuang",</span><br><span class="line">	age : 25,</span><br><span class="line">	job : "IT",</span><br><span class="line">	sayName : function()</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">friend.sayName();<span class="comment">//Uncaught TypeError: friend.sayName is not a function</span></span><br></pre></td></tr></table></figure></p>
<p>5.原生对象的原型<br>不建议修改原生对象的原型。</p>
<p>6.原型对象的问题</p>
<ul>
<li>省略了为构造函数传递初始化参数这一环节，结果所有实例在默认的情况下都将取得相同的属性值。</li>
<li>最大的问题是有共享的本性造成的。<br>原型中的所有属性都可以被很多实例共享，但是对于包含引用类型的属性来说们就会出现很明显的问题。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="constructor"><span class="keyword">constructor</span> : Person,</span><br><span class="line">	name : "hzhuang",</span><br><span class="line">	age : 25,</span><br><span class="line">	job : "IT",</span><br><span class="line">	friends : ["a", "b"],</span><br><span class="line">	sayName : function()</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.friends.push(<span class="string">"c"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person2.friends);<span class="comment">//["a", "b", "c"]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>问题好明显，我只是修改了实例1的friends，但是却在所有的实例中反应出来了。基于此，单独的原型模式一般是不常用的。</p>
<h3 id="6-2-4_组合使用构造函数模式和原型模式">6.2.4 组合使用构造函数模式和原型模式</h3><ul>
<li>构造函数用于定于实例属性；</li>
<li>原型模式用于定于方法和共享的属性。</li>
</ul>
<p>重写之前有问题的例子：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">this</span>.job = job;</span><br><span class="line">	<span class="keyword">this</span>.friends = [<span class="string">"a"</span>, <span class="string">"b"</span>];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="constructor"><span class="keyword">constructor</span> : Person,</span><br><span class="line">	sayName : function()</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见这种混合模式的优点：</p>
<ul>
<li>每个实例都有自己的实例属性的副本，同时又有共享的方法。</li>
<li>最大限度的节省了内存</li>
<li>还支持构造函数传递参数</li>
</ul>
<h3 id="6-2-5_动态原型模式">6.2.5 动态原型模式</h3><p>把所有的信息封装在构造函数中，而通过在构造函数中初始化原型，又保持了同时使用构造函数和原型的优点。就是说<strong>可以通过检测某个应该存在的方法是否有效，来决定是否需要初始化原型</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">this</span>.job = job;</span><br><span class="line">	<span class="keyword">this</span>.friends = [<span class="string">"a"</span>, <span class="string">"b"</span>];</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>)&#123;</span><br><span class="line">		Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"hzhuang"</span>, <span class="number">25</span>, <span class="string">"IT"</span>);</span><br><span class="line">friend.sayName();</span><br></pre></td></tr></table></figure></p>
<p>if( )部分只会在初次调用函数的时候执行，之后原型就完成初始化。此时原型的修改都会反映在实例中。</p>
<h3 id="6-2-6_寄生构造函数模式">6.2.6 寄生构造函数模式</h3><p>创建一个函数，这个函数的作用就是封装创建对象的代码，然后再返回新创建的对象。和工厂模式一样，区别只是这里是在一个函数里面并返回的这个对象。</p>
<h3 id="6-2-7_稳妥构造函数模式">6.2.7 稳妥构造函数模式</h3><ul>
<li>没有公共属性。</li>
<li>也不用this对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">	o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(name); <span class="comment">//不使用this</span></span><br><span class="line">	&#125;；</span><br><span class="line">	<span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了调用sayname( )方法外，没有其他方法可以访问到传入到构造函数中的原始数据，保证了一种安全性。</p>
<h2 id="6-3_继承">6.3 继承</h2><p>js没有接口继承，只支持实现继承。</p>
<h3 id="6-3-1_原型链">6.3.1 原型链</h3><p>原型链是实现继承的主要方法。<br>基本思路：利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>
<p>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而每个实例都包含一个指向原型函数对象的内部指针。<strong>如果将原型对象等于另一个类型的实例。则就会形成一个链</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承SuperType( )</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue());</span><br></pre></td></tr></table></figure>
<p>几点说明：</p>
<ul>
<li>instance.constructor指向SuperType，因为SubType的原型重写了。</li>
<li>instance指向SubType的原型</li>
<li>SubType的原型又指向SuperType的原型</li>
</ul>
<p>1.别忘记默认的原型<br>所有的函数的默认原型都是Object的实例，因此默认原型都会包含一个内部的指针，指向Object.prototype。这就是为什么函数可以继承toString( )等默认方法的根本原因。</p>
<p>2.确定原型和和实例的关系<br>两种方式：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方式</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">instanceof</td>
<td style="text-align:left">只要用这个操作符来测试实例与原型链中出现的构造函数，就会返回true。</td>
</tr>
<tr>
<td style="text-align:left">isPrototypeOf( )</td>
<td style="text-align:left">只要是原型链中出现过的原型，都可以说是该原生链所派生的实例的原型。</td>
</tr>
</tbody>
</table>
<p>3.谨慎的定义方法<br>给原型添加方法的代码一定要放在替换原型的语句之后。<br>必须在用要被继承的构造函数的实例替换当前的原型之后，再定义方法。<br>通过原型链实现继承的时候，不能使用对象字面量创建原型方法。因为这样会重写原型链。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承SuperType()</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line">SubType.prototype = &#123;</span><br><span class="line">	getSubValue : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">	&#125;,</span><br><span class="line">	someOhterMethod : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue()); <span class="comment">//error</span></span><br></pre></td></tr></table></figure></p>
<p>刚刚把SuperType的实例赋值给原型，接着又将原型替换成一个对象字面量而导致的问题。由于现在的原型包含的是一个Object的实例，而非SuperType的实例，因此我们设想的原型链已经被切断了。</p>
<p>4.原型链的问题<br>最大的问题是引用类型值的原型。还是共享问题。引用类型。<br>基于此，很少单独使用原型链。</p>
<h3 id="6-3-2_借用构造函数">6.3.2 借用构造函数</h3><p>解决单独原型链中引用类型带来的问题，借用构造函数的技术。<br>基本思想：在子类型构造函数的内部调用超类型构造函数。函数是特定环境中执行代码的对象，可以使用apply( )和call( )方法在新创建的对象上执行构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">//继承SuperType</span></span><br><span class="line">	SuperType.call(<span class="keyword">this</span>, <span class="string">"hzhaung"</span>);<span class="comment">//hzhuang是传递的参数。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">"blcak"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//["red", "blue", "green", "blcak"]</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);<span class="comment">//["red", "blue", "green"]</span></span><br></pre></td></tr></table></figure>
<p>在新SubType对象上执行SuperType( )函数中定义的所有对象初始化代码。<br>1.传递参数<br>2.借用构造函数的问题<br>方法在构造函数中定义，所以就无法复用。</p>
<h3 id="6-3-3_组合继承">6.3.3 组合继承</h3><p>将原型链和借用构造函数的技术组合在一起。<br>思路：使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样在原型上定义的方法实现了函数的复用，又可以保证每个实例有它自己的属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//继承SuperType</span></span><br><span class="line">	SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"hzhuang"</span>, <span class="number">25</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"blcak"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//["red", "blue", "green", "blcak"]</span></span><br><span class="line">instance1.sayName();<span class="comment">//hzhuang</span></span><br><span class="line">instance1.sayAge();<span class="comment">//25</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"hz"</span>, <span class="number">26</span>);</span><br><span class="line">instance2.sayName();<span class="comment">//hz</span></span><br><span class="line">instance2.sayAge();<span class="comment">//26</span></span><br></pre></td></tr></table></figure></p>
<h3 id="6-3-4_原型式继承">6.3.4 原型式继承</h3><p>没有严格意义上的构造函数。借助原型可以基于已有的对象创建新对象，同时还不比创建自定义类型。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span><span class="params">(o)</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span></span>&#123;</span><br><span class="line">		F.prototype = o;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在object函数内部，先创建了yige 临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回这个临时类的一个新实例。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">		F.prototype = o;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	name : <span class="string">"hzhuang"</span>,</span><br><span class="line">	friends : [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = object(person);</span><br><span class="line">anotherPerson.name = <span class="string">"hz"</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yetanotherPerson = object(person);</span><br><span class="line">yetanotherPerson.name = <span class="string">"hh"</span>;</span><br><span class="line">yetanotherPerson.friends.push(<span class="string">"e"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.friends);<span class="comment">//["a", "b", "c", "d", "e"]</span></span><br></pre></td></tr></table></figure></p>
<p>在上面的实例中，可以用Object.create( )来代替自定义的object函数。但是可以达到相同的效果。</p>
<h3 id="6-3-5_寄生式继承">6.3.5 寄生式继承</h3><p>思路与寄生构造函数和工厂模式类似，即创建一个仅仅用于<strong>封装继承过程的函数</strong>，改函数内部已某种方式增强对象。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span><span class="params">(o)</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">		F.prototype = o;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	name : <span class="string">"hzhuang"</span>,</span><br><span class="line">	friends : [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span><span class="params">(original)</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> <span class="keyword">clone</span> = object(original);</span><br><span class="line">	<span class="keyword">clone</span>.sayHi = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> console.log(<span class="string">"hi"</span>);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">clone</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi();</span><br></pre></td></tr></table></figure></p>
<h3 id="6-3-6_寄生组合式继承">6.3.6  寄生组合式继承</h3><p>基本思路：不必为了指定子类型的原型而调用超类型的构造函数，所需要的无非是超类型原型的一个副本人而已。本质上使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span><span class="params">(subType, superType)</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> prototype = object(superType.prototype);<span class="comment">//创建对象，创建超类型原型的一个副本。</span></span><br><span class="line">	prototype.constructor = subType;<span class="comment">//增强对象</span></span><br><span class="line">	subType.prototype = prototype;<span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="第七章_函数表达式">第七章 函数表达式</h1><ul>
<li>函数表达式的特征</li>
<li>使用函数实现递归</li>
<li>使用闭包定义私有变量</li>
</ul>
<p>函数声明可以先调用，然后再声明，不会跑出错误。但是如果你使用函数表达式的方法，则必须先创建函数啊，然后调用。</p>
<p>函数表达式：var huang=function（a，b）{}；这种情况叫做匿名函数，因为function后面没有标识符。在使用前必须先赋值。</p>
<h2 id="7-1_递归">7.1 递归</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">factorial</span><span class="params">(num)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(num &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> num*arguments.callee(num-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>arguments.callee是一个指向正在执行函数的指针。</p>
<h2 id="7-2_闭包">7.2 闭包</h2><p>闭包：有权访问另一个函数作用域中的变量的函数。最常见的方式就是在一个函数内部创建另一个函数。</p>
<p>函数被调用的时候，会创建一个执行环境和相应的作用域链，然后用arguments或者其他命名参数来初始化函数的活动对象。</p>
<ul>
<li>每一个执行环境都有有一个变量对象。全局变量对象始终存在，而局部的活动对象（本地活动对象）只在函数执行的过程中存在。</li>
<li>作用域链的本质是一个指向变量对象的指针列表，它只是引用。</li>
</ul>
<p>在另一个函数内部定义的函数会将包含函数（外部函数）的活动对象添加到它的作用域中。<br>函数调用完成后不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。</p>
<p>###7.2.1 闭包和变量<br>闭包中保存的是整个变量对象，所以闭包只能取得包含函数中任何变量的最后一个值。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function createFunctions()&#123;</span><br><span class="line">	<span class="keyword">var</span> <span class="literal">result</span> = new <span class="type">Array</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">		<span class="literal">result</span>[i] = function()&#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> funcs = createFunctions();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">	document.write(funcs[i]() + <span class="string">"&lt;br /&gt;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出的全是10，值得注意的是：funcs[i]输出的是一个函数，则在后面加上()就会执行返回i的值。<br>想到达预期的效果，则如下：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function createFunctions()&#123;</span><br><span class="line">	<span class="keyword">var</span> <span class="literal">result</span> = new <span class="type">Array</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">		<span class="literal">result</span>[i] = function(num)&#123;</span><br><span class="line">			<span class="keyword">return</span> function()&#123;</span><br><span class="line">				<span class="keyword">return</span> num;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###7.2.2 关于this对象<br>匿名函数的执行环境具有全局性，因此一般this指向window。但是有时候由于闭包的方式不同，这一点可能不同。<br>闭包中，内部函数是在先搜索自己内部的活动对象那个，如果找不到的话就会继续搜索外部包含它的函数。<br>如果将外部函数作用域中的this对象保存在一个闭包能够访问的变量里。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> that.xxx; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###7.2.3 内存泄露<br>内存泄露：闭包会引用包含函数的整个活动对象。<br>这种方式可以有效的回收内存。</p>
<p>##7.3 模仿块级作用域<br>js没有块级作用域的概念，所以对于for里面的声明的变量在函数内部也是可以读取的。对后续的声明无视，但是初始化值会执行。匿名函数模仿块级作用域（私有作用域）。<br>区别：<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">function</span><span class="list">(<span class="keyword">args</span>)</span><span class="collection">&#123; //这是一个函数表达式，后面加上<span class="list">()</span>表示立即调用。</span><br><span class="line">	xxx; //块级作用域。</span><br><span class="line">&#125;</span>)</span><span class="list">()</span></span><br></pre></td></tr></table></figure></p>
<p>如果没有保住function的括号，则就是函数声明，函数声明后面是不能加括号的。</p>
<p>##7.4 私有作用域<br>没有私有成员的概念，但是有私有变量的概念。（函数中定义的都是私有变量）<br>访问私有变量的公有方法：就是在函数内部调用一个特殊的方法，利用闭包的作用链来访问这些私有变量和私有方法。构造函数实现，对每个实例都重新创建。</p>
<p>###7.4.1 静态私有变量<br>在私有作用域中定义私有变量和函数，也可以创建特权方法。<br>在匿名函数里面，通过不声明函数的方法使这个方法成为全局的，所有就可以在私有作用域之外也可以访问到私有变量和方法。<br>区别：私有变量和方法是实例共享的。实例的参数变化会影响所有的实例。</p>
<p>###7.4.2 模块模式<br>在定义私有变量和函数后，return一个对象字面量。这个对象字面量包含可以公开的属性和方法。</p>
<h1 id="第八章_BOM">第八章 BOM</h1><p>主要内容</p>
<ul>
<li>理解window对象</li>
<li>控制窗口、框架和弹出窗口</li>
<li>location对象中的页面信息</li>
<li>navigator对象了解浏览器</li>
</ul>
<h2 id="8-1_window对象">8.1 window对象</h2><p>BOM的核心对象是window，它表示浏览器的一个实例。</p>
<ul>
<li>window对象既是js访问浏览器窗口的一个接口。</li>
<li>window也是ECMAScript规定的Global对象。网页中定义的对象、函数等都以window作为Global对象。</li>
</ul>
<h3 id="8-1-1_全局作用域">8.1.1 全局作用域</h3><p>由于window的特性，所以在在全局作用域中声明的变量、函数都会变成window对象的属性和方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">29</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayAge</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.age);</span><br><span class="line">sayAge();</span><br><span class="line"><span class="built_in">window</span>.sayAge();</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>定义全局变量与在window对象上定义属性还有一点差别：全局变量不能通过delete操作符删除，但是在window对象上定义的属性可以使用这个操作符。</p>
</blockquote>
<h3 id="8-1-2_窗口关系及框架">8.1.2 窗口关系及框架</h3><p>页面中如果有框架，则每个框架都有自己的window对象。保存在frames集合中。每个window都有各自的name属性。<br>不常用，忽略。</p>
<h3 id="8-1-3_窗口位置">8.1.3 窗口位置</h3><p>screenLeft和screenTop属性，分别用于表示窗口相对于屏幕左边和上面的位置。特别的是：在FireFox中，是screenX和screenY两个属性来完成相同的功能。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> leftPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenLeft == <span class="string">"number"</span>)?<span class="built_in">window</span>.screenLeft : <span class="built_in">window</span>.screenX;</span><br><span class="line"><span class="keyword">var</span> topPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenTop == <span class="string">"number"</span>)?<span class="built_in">window</span>.screenTop : <span class="built_in">window</span>.screenY;</span><br></pre></td></tr></table></figure></p>
<p>关于方法moveTo( )和moveBy( )浏览器一般是禁用的。</p>
<h3 id="8-1-4_窗口大小">8.1.4 窗口大小</h3><p>关于窗口大小属性的四个：outerWidth/innerWidth/outerHeight/innerOuter在各浏览器中的渲染差别。</p>
<ul>
<li>IE9+、Safari和FireFox：outerWidth/outerHeight返回浏览器窗口本身的尺寸。</li>
<li>Opera： outerWidth/outerHeight表示页面视图容器的大小。</li>
<li>Chrome：innerWidth/innerHeight一般表示页面中视图区的大小（减去边框宽度）。而chrome中这对属性的值和outerWidth/outerHeight返回的值大小是一样的，都表示视口的大小。</li>
</ul>
<p>跨浏览器确定浏览器的窗口无法实现，但是可以获取到页面视口的大小。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pageWidth = <span class="built_in">window</span>.innerWidth;</span><br><span class="line"><span class="keyword">var</span> pageHeight = <span class="built_in">window</span>.innerHeight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> pageWidth != <span class="string">"number"</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">document</span>.compatMode == <span class="string">"CSS!compatMode"</span>)&#123; <span class="comment">//检查是否处于标准模式</span></span><br><span class="line">		pageWidth =<span class="built_in">document</span>.documentElement.clientWidth;</span><br><span class="line">		pageHeight = <span class="built_in">document</span>.documentElement.clientHeight;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		pageWidth = <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line">		pageHeight = <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>移动设备中，IE的浏览器的视口大小的值是可见视口的值，而其他浏览器的值就是布局视口的值。</p>
<p>同样有resizeTo( )和resizeBy( )，但是一般浏览器禁止。</p>
<h3 id="8-1-5_导航和打开窗口">8.1.5 导航和打开窗口</h3><p>window.open( )可以打开导航到一个特定的URL，也可以打开一个新的浏览器窗口。<br>window.open( )接受四个参数：要加载的URL、窗口目标、一个特性字符串以及新页面是否取代浏览器历史记录中当前加载页面的布尔值。</p>
<ul>
<li>第一个参数：要加载的URL</li>
<li>第二个参数：窗口目标。<ul>
<li>已存在的窗口或者框架属性。</li>
<li>特殊的窗口名称：_self、_parent、_top或_blank。</li>
</ul>
</li>
<li>第三个参数：在第二个参数并不是一个存在的窗口或者框架的时候。则会根据第三个设置的特性值新建窗口或者框架。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">特性值</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">fullscreen,取值yes或no</td>
<td style="text-align:left">仅限IE</td>
</tr>
<tr>
<td style="text-align:left">height</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">left</td>
<td style="text-align:left">新窗口的左坐标</td>
</tr>
<tr>
<td style="text-align:left">location取值yes或no</td>
<td style="text-align:left">是否在新窗口中显示地址栏</td>
</tr>
<tr>
<td style="text-align:left">menubar取值yes或no</td>
<td style="text-align:left">是否在新窗口中显示菜单栏</td>
</tr>
<tr>
<td style="text-align:left">resizeable</td>
<td style="text-align:left">是否可以通过拖动浏览器窗口的边框改变其大小</td>
</tr>
<tr>
<td style="text-align:left">scrollbars</td>
<td style="text-align:left">是否允许有滚动</td>
</tr>
<tr>
<td style="text-align:left">status</td>
<td style="text-align:left">是否在新窗口中显示状态栏</td>
</tr>
<tr>
<td style="text-align:left">toolbar</td>
<td style="text-align:left">是否在新窗口中显示工具栏</td>
</tr>
<tr>
<td style="text-align:left">top</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">width</td>
<td style="text-align:left">无</td>
</tr>
</tbody>
</table>
<p>以上的设置值是yes或者no的默认值都是no。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> hzhuang</span> = window.<span class="keyword">open</span>(<span class="string">"http://localhost:4000/"</span>, <span class="string">"hzhaung"</span>, <span class="string">"height=400,width:400,resizeable=no"</span>);</span><br></pre></td></tr></table></figure></p>
<p>window.close( )方法用于关闭新打开的窗口。浏览器主窗口是不可以使用这个方法的，凡是弹出的窗口却可以。</p>
<p>新创建的window对象有一个<strong>opera属性</strong>，保存着打开它的原始窗口对象。</p>
<p>可以通过设置这些特性字符串来处理网页上肆无忌惮的广告问题。</p>
<p><strong>弹出窗口屏蔽程序</strong><br>大多数浏览器都内置屏蔽弹出窗口。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> blocked</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="variable"><span class="keyword">var</span> wroxWin</span> = window.<span class="keyword">open</span>(<span class="string">"http://www.wrox.com"</span>, <span class="string">"_blank"</span>);</span><br><span class="line">    <span class="keyword">if</span> (wroxWin == <span class="literal">null</span>)&#123;</span><br><span class="line">        blocked = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ex)&#123;</span><br><span class="line">    blocked = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (blocked)&#123;</span><br><span class="line">    alert(<span class="string">"The popup was blocked!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="8-1-6_间歇调用和超时调用">8.1.6 间歇调用和超时调用</h3><p>windo对象的setTimeout( )方法。<br>这个方法会返回一个数值ID，表示超时调用。用clearTimeout(set方法返回的值)来取消。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timeoutID = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"hzhuang"</span>);&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(timeoutID);<span class="comment">//1</span></span><br></pre></td></tr></table></figure></p>
<p>window对象的setInterval( )实现间歇调用。</p>
<h3 id="8-1-7_系统对话框">8.1.7 系统对话框</h3><p>三种：alert() + confirm( ) + prompt( )</p>
<ul>
<li>与显示的网页没有关系。</li>
<li>外观由操作系统决定，并非css。</li>
<li>显示的时候代码是停止执行的。</li>
</ul>
<h2 id="8-2_location对象">8.2 location对象</h2><p>​location对象即是window对象的属性，也是document对象的属性。</p>
<ul>
<li>保存当前文档的信息</li>
<li>将URL解析成独立的片段</li>
</ul>
<p>以“<a href="http://www.wrox.com:80#contents”为例" target="_blank" rel="external">http://www.wrox.com:80#contents”为例</a></p>
<table>
<thead>
<tr>
<th style="text-align:left">属性名</th>
<th style="text-align:left">例子</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">hash</td>
<td style="text-align:left">“#contents”</td>
<td style="text-align:left">URL的hash，就是#号后面的字符串</td>
</tr>
<tr>
<td style="text-align:left">host</td>
<td style="text-align:left">“www.wrox.com”80”</td>
<td style="text-align:left">返回服务器名称和端口号</td>
</tr>
<tr>
<td style="text-align:left">hostname</td>
<td style="text-align:left">…</td>
<td style="text-align:left">返回服务器名</td>
</tr>
<tr>
<td style="text-align:left">href</td>
<td style="text-align:left">“<a href="http://www.wrox.com”" target="_blank" rel="external">http://www.wrox.com”</a></td>
<td style="text-align:left">返回当前加载页面的完整URL</td>
</tr>
<tr>
<td style="text-align:left">pathname</td>
<td style="text-align:left">/…/</td>
<td style="text-align:left">url的路径名</td>
</tr>
<tr>
<td style="text-align:left">port</td>
<td style="text-align:left">“80”</td>
<td style="text-align:left">端口</td>
</tr>
<tr>
<td style="text-align:left">protocal</td>
<td style="text-align:left">“http”</td>
<td style="text-align:left">协议</td>
</tr>
<tr>
<td style="text-align:left">search</td>
<td style="text-align:left">”？q=javascript“</td>
<td style="text-align:left">返回URL中的查询字符串，以问号开头</td>
</tr>
</tbody>
</table>
<h3 id="8-2-1_查询字符串参数">8.2.1 查询字符串参数</h3><p>解决location.search只能返回问号后面全部字符串而不精确的问题。<br>构造一个函数，解析查询字符串，然后返回包含所有参数的一个<em>对象</em>。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">getQueryStringArgs</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> qs = (location.search.length &gt; <span class="number">0</span> ? location.search.substring(<span class="number">1</span>) : <span class="string">""</span>),</span><br><span class="line">	args = &#123;&#125;,<span class="comment">//保存数据的对象</span></span><br><span class="line">	<span class="comment">//获取每一项</span></span><br><span class="line">	items = qs.length ? qs.split(<span class="string">"&amp;"</span>) : [],</span><br><span class="line">	item = <span class="keyword">null</span>,</span><br><span class="line">	name = <span class="keyword">null</span>,</span><br><span class="line">	<span class="keyword">value</span> = <span class="keyword">null</span>,</span><br><span class="line">	i = <span class="number">0</span>,</span><br><span class="line">	len = items.length;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;len ;i++)&#123;</span><br><span class="line">		item = items[i].split(<span class="string">"="</span>);</span><br><span class="line">		name = decodeURLComponent(item[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">value</span> = decodeURLComponent(item[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">if</span>(name.length)&#123;</span><br><span class="line">			args[name]= <span class="keyword">value</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###8.2.2 位置操作<br>location对象可以用很多方式改变浏览器的位置。常用的是<strong>assign( )</strong>。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.<span class="function"><span class="title">assign</span><span class="params">(<span class="string">"http://huangzhuang.github.io/"</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>以上代码可以立即打开我的博客，并在浏览器中的历史记录中生成一条记录。</p>
<blockquote>
<p>window.location和location.href设置成URL时，也会调用assign的方法，达到相同的效果。</p>
</blockquote>
<p>同时设置location对象的其他属性也可以改变URL。</p>
<p>为了禁止在浏览器器中生成历史记录，可以采用<strong>replace( )</strong>的方法。</p>
<p>最后一个方法是reload( )，重新加载当前页面。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.<span class="function"><span class="title">reload</span><span class="params">(true)</span></span> <span class="comment">//带true表示的是从服务器中重新加载的。</span></span><br></pre></td></tr></table></figure></p>
<h2 id="8-3_navigator对象">8.3 navigator对象</h2><p>关于属性，不常用，详见P210.</p>
<h3 id="8-3-1_检测插件">8.3.1 检测插件</h3><p>对于非IE浏览器而言，使用plugins数组来实现插件检测。</p>
<p>plugins数组有以下的属性：</p>
<ul>
<li>name 插件的名字。</li>
<li>description插件的描述。</li>
<li>filename插件的文件名。</li>
<li>length插件所处理的MIME类型数量。</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测是否有xx插件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPlugin</span><span class="params">(name)</span></span>&#123;</span><br><span class="line">	name = name.toLowwerCase();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;navigator.plugins.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(navigator.plugins[i].name.toLowwerCase().indexOf(name) &gt; -<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要再IE浏览器中检查插件，则使用唯一的专有的ActiveXObjext类型。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//plugin detection for IE</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasIEPlugin</span><span class="params">(name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> ActiveXObject(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ex)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###8.3.2 注册处理程序</p>
<p>##8.4 screen对象<br>screen对象基本上只用来表明客户端的能力。<br>属性详见P214</p>
<h2 id="8-5history对象">8.5history对象</h2><p>history是window对象的属性。借由用户访问过的页面列表，可以实现在不知道实际URL的情况下实现后退和前进。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">history</span>.<span class="keyword">go</span>(num/url);</span><br><span class="line"><span class="keyword">history</span>.back();</span><br><span class="line"><span class="keyword">history</span>,forward();</span><br></pre></td></tr></table></figure></p>
<p>#第十章 DOM</p>
<ul>
<li>理解包含不同层次节点的DOM</li>
<li>使用不同的节点类型</li>
<li>克服浏览器兼容性问题以及各种陷阱</li>
</ul>
<h2 id="10-1_节点层次">10.1 节点层次</h2><p>所有页面标记则表现为一个以特定节点为根节点的树形结构。</p>
<h3 id="10-1-1_Node类型">10.1.1 Node类型</h3><p>每个节点有nodeType属性。<br> 为了兼容所有浏览器，最好是将nodeType的值与1-12之间的数值比较。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（somenode.nodeType = =<span class="number">1</span>）&#123;alert(<span class="string">"该节点是一个元素节点"</span>)&#125;</span><br></pre></td></tr></table></figure></p>
<p>####1.nodeName和nodeValue属性<br>nodeName和nodeValue属性是节点的具体信息，使用前检测下节点的类型。<br>元素节点的nodeName是标签名，而它的nodeValues是null。</p>
<p>####2. 节点关系<br>每个节点都有一个<strong>childNodes属性</strong>，保存着nodeList对象（一个类数组，用于保存一组有序的节点）。<br>nodeList对象有length属性，且并不是Array的实例，而是会随时变化的，随DOM的结构变化自动变化。<br>通过方括号或者item()方访问nodeList中的节点。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> firstChild</span> = someNode.childNodes[<span class="number">0</span>];</span><br><span class="line"><span class="variable"><span class="keyword">var</span> secondChild</span> = someNode.childNodes.item[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//将nodeLists转化成数组。</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> arrayOfNodes</span> = Array.prototype.slice.call(someNode.childNodes, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>关于Array.prototype.slice.call()可以将arguments对象转成数组，<a href="http://www.cnblogs.com/littledu/archive/2012/05/19/2508672.html" target="_blank" rel="external">参考解释</a>。<br>大致是先调用toArray()方法，然后再执行slice()方法。</p>
<p>关于将nodeList对象转换成数组，兼容IE8及以下的方法是：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function<span class="function"> convertToArray(</span>nodes<span class="function">)</span>&#123;</span><br><span class="line">	var<span class="instruction"> array </span>= <span class="keyword">[</span>];</span><br><span class="line">	try&#123;</span><br><span class="line">		//针对非IE8及以下浏览器</span><br><span class="line">	<span class="instruction">	array </span>=<span class="function"> Array.prototype.slice.call(</span>nodes, 0<span class="function">)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	catch(ex<span class="function">)</span>&#123;</span><br><span class="line">	<span class="instruction">	array </span>=<span class="instruction"> new </span>Array(<span class="function">)</span>;</span><br><span class="line">		for(var i=0, len= nodes.length; i&lt; len; i++<span class="function">)</span>&#123;</span><br><span class="line">			array<span class="keyword">[</span>i].push(nodes<span class="keyword">[</span>i]<span class="function">)</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="instruction">	return </span>array; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每个节点有一个<strong>parentNode属性</strong>，指向文档树中的父节点。<br>比如someNode.childNodes中的每个节点都有同样的父节点someNode。而且他们之间是同胞节点（previousSibling 和 nextSbling）。</p>
<p>firestChild和lastChild属性的意义就很明显了。<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">someNode.firstChild == someNode.childNodes<span class="string">[0]</span>;</span><br><span class="line">someNode,lastCHild == someNode.childNodes<span class="string">[someNode.childNodes.length - 1]</span>;</span><br></pre></td></tr></table></figure></p>
<p>hasChildNodes()方法：节点包含一个或者多个子节点的情况下返回true</p>
<p>每个节点还有一个<strong>ownerDocument属性</strong>，指向文档的文档节点。不可以跨几个。</p>
<p>####3.操作节点<br>|方法|描述|<br>|:—|:—|<br>|appendChild( )|用于向childNodes列表的末尾添加一个节点。这个方法会<strong>返回新增的节点</strong>。|<br>|insertBefore()|(插入的节点，作为参考的节点 )|<br>|replaceChild()|（插入的节点，要替换的节点）|<br>|removeChild|（移除的节点）|<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> huang</span>= someNode.appendChild(newNode);</span><br><span class="line">alert (huang == newNode); <span class="comment">//返回true;</span></span><br></pre></td></tr></table></figure></p>
<p>如果要传入的节点已经是DOM的一部分，则结果就是将该节点从原来的位置转移到新的位置。（实现转移！）</p>
<blockquote>
<p>四种操作方法都是摸个节点的子节点，如果是不支持子节点的节点就会报错的。比如文本节点没有子节点。</p>
</blockquote>
<p>两个所有节点都有的方法：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">cloneNode(true)</td>
<td style="text-align:left">true表示深复制，就是复制节点及其子节点树。复制后孤立。不会复制js属性。</td>
</tr>
<tr>
<td style="text-align:left">normalize()</td>
<td style="text-align:left">删除后代中的空文本节点，然后把相邻的文本节点合并。</td>
</tr>
</tbody>
</table>
<p>###10.1.2 Document类型(9)<br>nodeType == 9<br>document对象是HTMLDocument的一个实例，表示整个HTML页面。且是window对象的一个属性。</p>
<p>####1.文档的子节点<br>内置两个访问子节点的快捷方式,所有的浏览器均支持这两个。</p>
<ul>
<li>documentElement指向html标签，这个更加方便快捷。</li>
<li>通过childNodes列表访问。</li>
</ul>
<p>一下三个是等价的。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> html</span> =document.documentElement;</span><br><span class="line"><span class="variable"><span class="keyword">var</span> html1</span> = document.childNodes[<span class="number">0</span>];</span><br><span class="line"><span class="variable"><span class="keyword">var</span> html2</span> = doxument.firstChild;</span><br></pre></td></tr></table></figure></p>
<p>document对象有body属性<br><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">body</span> = document.<span class="keyword">body</span>;</span><br></pre></td></tr></table></figure></p>
<p>documen对象有doctype属性,各浏览器支持差异，使用不多。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dovtype = <span class="built_in">document</span>.doctype;</span><br></pre></td></tr></table></figure></p>
<p>对于出现在html之外的注释，各个浏览器解析也存在差异。也就是document的childNodes不同。</p>
<ul>
<li>IE8及以前，safari3.1及以后。为第一个注释创建节点。其他的就忽略。</li>
<li>IE9及以上，就是正常的情况，所有的注释都是创建了节点。</li>
<li>Firefox和safari以前，完全忽略注释的存在。</li>
</ul>
<p>####2.文档信息<br>作为HTMLDocument的实例，有一些特别的属性。</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">title</td>
<td style="text-align:left">document.title</td>
</tr>
<tr>
<td style="text-align:left">URL</td>
<td style="text-align:left">包含页面完整的URL</td>
</tr>
<tr>
<td style="text-align:left">domain</td>
<td style="text-align:left">只包含域名</td>
</tr>
<tr>
<td style="text-align:left">referrer</td>
<td style="text-align:left">保存着链接到当前页面的那个页面的URL</td>
</tr>
</tbody>
</table>
<p>后面的三个属性是与网页的请求有关，存在请求的http头部。且只有domian是可以设置的，但是不可以任意设置。而且可以把子域设置成域而不能把域设置成子域（不能loose到tight）。</p>
<p>理解是这样的：<br>由于跨域，不同的子域的页面是无法通过js通信。可是将两个子域的domian设置为相同的值就可以通信了。</p>
<p>####3.查找元素，document对象的几个方法。</p>
<ul>
<li>document.getElementById():很常见，但是要注意一点就是在IE8及以下中会返回name值等于这个id名的表单元素。</li>
<li><p>document.getElementsByTagName：返回一个HTMLCollection对象，这个对象与nodeList对象类似，也可以使用方括号或者item()来读取。<br>这个HTMLCollection对象还有一个namedItem方法，来获取这个集合中name特性的项。则可以知道：HTMLCollection而言，可以传入数值或者字符串，前者后台会调用item(),后者则调用namedItem()。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> img</span> = doceument.getElemmentdbyTagName(<span class="string">"img"</span>);</span><br><span class="line"><span class="variable"><span class="keyword">var</span> myImg</span> = img.namedItem(<span class="string">"hzhuang"</span>);<span class="comment">//可以获取到name是hzhuang的那张图片。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>document.getElementByName()。</p>
</li>
</ul>
<p>####4.特殊集合<br>这些特殊的集合都是HTMLCollection对象。</p>
<table>
<thead>
<tr>
<th style="text-align:left">集合</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">document.anchors</td>
<td style="text-align:left">包含文档中所有带name特性的a标签</td>
</tr>
<tr>
<td style="text-align:left">document.forms</td>
<td style="text-align:left">包含文档中所有的form元素</td>
</tr>
<tr>
<td style="text-align:left">document.images</td>
<td style="text-align:left">包含文档中所有img标签</td>
</tr>
<tr>
<td style="text-align:left">document.links</td>
<td style="text-align:left">包含文档中所有带href属性的a元素</td>
</tr>
</tbody>
</table>
<p>#####5.DOM一致性检测<br>检测浏览器实现了DOM的哪些部分。<br><strong>document.implementation</strong>属性就是来实现这个功能的。<br>它有一个方法hasFeature().如果浏览器支持给定名称和版本的功能就会返回true。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasXmlDom = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">"XML"</span>, <span class="string">"1.0"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(hasXmlDom); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>####6.文档写入<br>将输出流写出到网页中。</p>
<ul>
<li>write:参数里面包含script标签时闭合的/要转义。</li>
<li>writeIn会自动在后面加上（/n）。</li>
</ul>
<p>###10.1.3 Element类型(1)<br>nodeType == 1<br>访问元素的标签名：</p>
<ul>
<li>nodeName属性</li>
<li>tagName属性</li>
</ul>
<p>在HTML返回的都是大写的。所以采用以下的方式进行比较返回的是否是哪个。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if<span class="list">(<span class="keyword">element</span>.nodeName.toLowerCase<span class="list">()</span> == <span class="string">"div"</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>####1.html元素<br>每个html元素都有以下的特性：</p>
<ul>
<li>id</li>
<li>title</li>
<li>dir：修改就会立即反映在页面中。</li>
<li>lang</li>
<li>className：改变值可以直接关联新的样式。</li>
</ul>
<p>####2.取得特性<br>操作特性的方法：<br>getAttribute() + setAttribute() + removeAttrvbute() </p>
<p>两类特殊的特性：</p>
<ul>
<li>style：getAttribute()返回的是style里面的文本。而通过属性来访问则是一个对象。</li>
<li>onclick：getAttribute()返回相应代码的字符串。而访问onclick属性时候返回的是一个js函数。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"huang"</span> <span class="attribute">onclick</span>=<span class="value">"huang()"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line">	<span class="keyword">var</span> str = <span class="built_in">document</span>.getElementById(<span class="string">"huang"</span>);</span><br><span class="line">	<span class="keyword">var</span> huang = str.getAttribute(<span class="string">"onclick"</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(str.onclick); <span class="comment">//function onclick</span></span><br><span class="line">	<span class="built_in">console</span>.log(huang); <span class="comment">//huang()</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">huang</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"123"</span>);</span><br><span class="line">	&#125;</span></span><br></pre></td></tr></table></figure>
<p>所以一般不适用getAttribute()这个方法，而是在访问自定义属性的时候用到。</p>
<p>####3.设置属性<br>setAttribute()<br>IE7及以下对于class和style的设置没有效果。<br>IE6不支持removeAttribute()</p>
<p>####4.attributes属性<br>atributes属性中包含一个NamedNodeMap，与nodeList类似。<br>有以下的方法：</p>
<ul>
<li>getNamedItem(name):返回nodeName等于name的节点。</li>
<li>removeNamedItem(name);</li>
<li>setNamedItem(name);</li>
<li>item(pos):返回位于数字跑pos位置处的节点。</li>
</ul>
<p>attributes属性包含一系列节点，每个节点的nodeName就是特性的名称。每个节点的nodeValue就是特性的值。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> id</span> = element.attributes.getNamedItem(<span class="string">"id"</span>).nodeValue;</span><br><span class="line">id = <span class="string">"huang"</span>;<span class="comment">//将id设置成新值。</span></span><br></pre></td></tr></table></figure>
<p>attributes属性一般用的不多，但是在<strong>遍历元素的特性</strong>的时候是很有用的。然后以name = value的形式输出。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id = <span class="string">"hzhuang"</span> name = <span class="string">"hzhuang"</span> dir = <span class="string">"ltr"</span> class = <span class="string">"hzhuang"</span> title=<span class="string">"hzhuang"</span>&gt;&lt;/div&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputAttribute</span><span class="params">(element)</span></span>&#123;</span><br><span class="line">	element = element.attributes;</span><br><span class="line">	var <span class="built_in">pairs</span> = [], attrName, attrValue, i , len=element.length;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; len; i++)&#123;</span><br><span class="line">		attrName = element[i].nodeName;</span><br><span class="line">		attrValue = element[i].nodeValue;</span><br><span class="line">		<span class="built_in">pairs</span>.push(attrName + <span class="string">"=\'"</span> + attrValue + <span class="string">"\'"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">pairs</span>.join(<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">var hzhuang = document.getElementById(<span class="string">"hzhuang"</span>);</span><br><span class="line">var output = outputAttribute(hzhuang);</span><br><span class="line">console.log(output);//id=<span class="string">'hzhuang'</span> name=<span class="string">'hzhuang'</span> dir=<span class="string">'ltr'</span> class=<span class="string">'hzhuang'</span> title=<span class="string">'hzhuang'</span></span><br></pre></td></tr></table></figure></p>
<p>####5.创建元素<br>cteateElement()来实现，然后使用节点添加的方法加到DOM中。<br>几个兼容性问题及解决：<br>兼容性：</p>
<ul>
<li>不能设置动态创建的iframe的name特性。</li>
<li>不同用reset()方法充值动态创建的input元素。</li>
<li>动态创建type是reset的button元素重设不了表单。</li>
<li>动态创建的一批name相同的单选按钮彼此之间没有联系。</li>
</ul>
<p>解决方法：<br>检测浏览器(只有IE7及以下支持这种写法)<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">client</span>.browser.ie &amp;&amp; <span class="keyword">client</span>.browser.ie &lt;= <span class="number">7</span>)&#123;</span><br><span class="line">	xxx<span class="comment">//使用参数是完整的元素标签。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>####6.元素的子节点<br>元素的childNodes属性包含所有的子节点：元素，文本节点，注释或者处理指令。<br>解析的差异：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">ul</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">li</span>&gt;</span>1<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">li</span>&gt;</span>2<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">li</span>&gt;</span>3<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>IE解析是ul.childNodes中只有三个子节点。</li>
<li>其他浏览器中解析出7个。（加上四个文本节点：空白符）</li>
</ul>
<p>所以采用以下的方法来实现三个<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for<span class="comment">(var i=0, len=element.childNodes.length; i&lt; len; i++)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span><span class="comment">(element.childNodes[i].nodeType == 1)</span>&#123;</span><br><span class="line">		xxx;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>元素也有getElementsByTagName()方法。</p>
<p>###10.1.4 Text类型(3)<br>nodeType == 3<br>nodeValue或者data属性可以访问到文本节点包含的文本。</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">appendData(text)</td>
<td style="text-align:left">将text添加到节点的末尾</td>
</tr>
<tr>
<td style="text-align:left">deleteData(offset, count)</td>
<td style="text-align:left">从offset指定的位置删除count个字符</td>
</tr>
<tr>
<td style="text-align:left">insertData(offset, text)</td>
<td style="text-align:left">从offset指定的位置添加text</td>
</tr>
<tr>
<td style="text-align:left">replaceData(offset,count, text)</td>
<td style="text-align:left">从offset指定的位置用text替换count个字符</td>
</tr>
<tr>
<td style="text-align:left">splitText(offset)</td>
<td style="text-align:left">指定的位置将当前文本节点分成两个文本节点。</td>
</tr>
<tr>
<td style="text-align:left">substringData(offset, count)</td>
<td style="text-align:left">提取从指定位置offset到offset+count位置处的字符串。</td>
</tr>
</tbody>
</table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeText</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line">	div.firstChild.nodeValue = <span class="string">"Some &lt;strong&gt;other&lt;/strong&gt; message"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后面的符号不需要转义，因为这个字符串会经过HTML编码。</span></span><br></pre></td></tr></table></figure>
<p>####1.创建文本节点<br>document.createTextNode()，然后使用添加节点的方式将它放进DOM。<br>如果添加两个相邻的文本节点，会将两个直接连接起来。且没有空格。但是还是存在两个文本节点。则使用规范化来解决这个问题。</p>
<p>####2.规范化文本节点<br>normalize()在包含一个或者几个文本节点的父节点上调用这个方法，则可以将所有的文本节点合并成一个。也就是说此时element.childNodes.length是等于1的。</p>
<p>####3.分割文本节点<br>splitText()方法的作用域normalize()的作用相反。</p>
<h3 id="10-1-5_Comment类型(8)">10.1.5 Comment类型(8)</h3><p>nodeType == 8<br>类似Text类型</p>
<h3 id="10-1-7_DocumentType类型(x)">10.1.7 DocumentType类型(x)</h3><p>不常用。</p>
<h3 id="10-1-8_DocumentFragment类型(11)">10.1.8 DocumentFragment类型(11)</h3><p>nodeType == 11<br>不可以直接添加在文档中，但是可以作为仓库来使用。<br>创建方法：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br></pre></td></tr></table></figure></p>
<p>看一个例子就明白了：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">"myList"</span>&gt;&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">"myList"</span>);</span><br><span class="line"><span class="keyword">var</span> li = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">	li = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">	li.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Item "</span> + (i+<span class="number">1</span>)));</span><br><span class="line">	fragment.appendChild(li);</span><br><span class="line">&#125;</span><br><span class="line">ul.appendChild(fragment);</span><br></pre></td></tr></table></figure></p>
<h2 id="11-2_DOM操作技术">11.2 DOM操作技术</h2><h3 id="11-2-1_动态脚本">11.2.1 动态脚本</h3><p>页面加载完的时候不存在，在将来的某一个时刻修改DOM动态添加的脚本。</p>
<ul>
<li>插入外部文件。</li>
<li>直接插入js代码。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = documet.createElement(<span class="string">"script"</span>);</span><br><span class="line">script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">script.src = <span class="string">"client.js"</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line"></span><br><span class="line"><span class="comment">//封装成函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> script = documet.createElement(<span class="string">"script"</span>);</span><br><span class="line">	script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">	script.src = url;</span><br><span class="line">	<span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种方式：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="actionscript"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">sayHi</span><span class="params">()</span></span>&#123;</span><br><span class="line">		alert(:hi);</span><br><span class="line">	&#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>要动态创建以上的那个js，则要考虑到兼容性的问题</p>
<ul>
<li>document.createTextNode(“function sayHi(){alert(‘hi’)}”除了IE浏览器不支持外，其他的均支持。 但是可以指定script标签的text属性来指定代码。</li>
<li>但是sarafi3.0之前的不支持text的属性。</li>
</ul>
<p>所以，以下就是封装好的函数，兼容性解决的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScriptString</span>(<span class="params">code</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">	script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		script.appendChild(<span class="built_in">document</span>.createTextNode(code));</span><br><span class="line">	&#125; <span class="keyword">catch</span> (ex)&#123;</span><br><span class="line">		script.appendChild(script.text = code);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="10-2-2_动态样式">10.2.2 动态样式</h3><p>也是两种方式<br>与script类似，但是区别的是link是放在head中的。封装好的函数如下。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadStyleString</span>(<span class="params">css</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> style = <span class="built_in">document</span>.createElement(<span class="string">"style"</span>);</span><br><span class="line">	style.type = <span class="string">"text/css"</span>;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		style.appendChild(<span class="built_in">document</span>.createTextNode(css));</span><br><span class="line">	&#125; <span class="keyword">catch</span> (ex)&#123;</span><br><span class="line">		style.styleSheet.cssText = css;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>];</span><br><span class="line">	head.appendChild(style);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="10-2-3_操作表格">10.2.3 操作表格</h3><p>忽略</p>
<h3 id="10-2-4_使用NodeList">10.2.4 使用NodeList</h3><p>理解”NodeList”以及”nameNodeMap”和”HTMLCollection”是理解DOM的关键。<br>他们是三个集合，而且是动态的，随着DOM的变化得到更新。<br>以下的例子会进入无限循环</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var divs = document.getElementsByTagName(<span class="string">"div"</span>) ,i, <span class="keyword">div</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; divs.<span class="property">length</span>; i++)&#123;</span><br><span class="line">	<span class="keyword">div</span> = document.createElement(<span class="string">"div"</span>);</span><br><span class="line">	document.body.appendChild(<span class="keyword">div</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决方法是只要把divs.length赋值给len，然后使用i小于len即可。</p>
<p>#第11章 DOM扩展</p>
<ul>
<li>Selector API</li>
<li>HTML5扩展</li>
<li>了解专有的DOM扩展</li>
</ul>
<h2 id="11-1_选择符_API">11.1 选择符 API</h2><p>扩展这个API是为了让原生浏览器支持css查询。</p>
<h3 id="11-1-1_querySelector()方法">11.1.1 querySelector()方法</h3><p>接收一个css选择符，返回与该模式匹配的第一个元素。<br>document.querySelector()在整个文档查找<br>element.querySelector()则只会在element的后代中查找匹配项。</p>
<h3 id="11-1-2_querySelectorAll()">11.1.2 querySelectorAll()</h3><p>这个方法与querySelector类似，但是返回的是一个nodeList对象。可以用item()方法来得到各项。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">var</span> <span class="keyword">strong </span>= document.querySelectorAll(<span class="string">"p strong"</span>)<span class="comment">;</span></span><br><span class="line"><span class="label">var</span> i , len<span class="comment">;</span></span><br><span class="line"><span class="label">for</span>(i = <span class="number">0</span> , len = <span class="keyword">strong.length </span><span class="comment">; i++)&#123;</span></span><br><span class="line">	 // <span class="keyword">strong </span>= <span class="keyword">strong[i];</span><br><span class="line"></span>	 <span class="keyword">strong </span>= <span class="keyword">strong.item(i);</span><br><span class="line"></span>	 <span class="keyword">strong.className </span>= <span class="string">"important"</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="11-1-3_matchesSelector()">11.1.3 matchesSelector()</h3><p>这个是element类型的一个方法。返回的是一个布尔值。<br>考虑兼容性问题，封装一个函数里。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function matchesSelect<span class="subst">or</span>(eleement, <span class="keyword">select</span><span class="subst">or</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(element<span class="built_in">.</span>matchesSelect<span class="subst">or</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> element<span class="built_in">.</span>matchesSelect<span class="subst">or</span>(<span class="keyword">select</span><span class="subst">or</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(element<span class="built_in">.</span>msMatchesSelect<span class="subst">or</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> element<span class="built_in">.</span>msMatchesSelect<span class="subst">or</span>(<span class="keyword">select</span><span class="subst">or</span>);</span><br><span class="line">	&#125;<span class="attribute">...</span><span class="attribute">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="11-2_元素遍历">11.2 元素遍历</h2><p>之前讨论过IE和其他浏览器中关于childNodes中包含空格符的不一致问题，现在为了解决这个问题，Element Traversal规范定义一组新的属性。</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">childElementCount</td>
<td style="text-align:left">返回子元素，不包含文本节点和注释</td>
</tr>
<tr>
<td style="text-align:left">firstElementChild</td>
<td style="text-align:left">指向第一个子元素</td>
</tr>
<tr>
<td style="text-align:left">lastElementChild</td>
<td style="text-align:left">指向最后一个子元素</td>
</tr>
<tr>
<td style="text-align:left">previousElementSibling</td>
<td style="text-align:left">指向前一个同辈元素</td>
</tr>
<tr>
<td style="text-align:left">nextElememntSibling</td>
<td style="text-align:left">指向下一个同辈元素</td>
</tr>
</tbody>
</table>
<h2 id="11-3_HTML5">11.3 HTML5</h2><p>###11.3.1与类相关的扩充</p>
<p>####1.getElementsByClassName()<br>H5新加了getElementsByClassName()方法。返回的是得到的所有匹配类的NodeList。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> allCurrentUserNames = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"username current"</span>);</span><br><span class="line"><span class="keyword">var</span> selected = <span class="built_in">document</span>.getElememntById(<span class="string">"myDiv"</span>).getElementsByClassName(<span class="string">"selected"</span>);</span><br></pre></td></tr></table></figure></p>
<p>####2.classList属性<br>可以使用className属性来添加、删除和替换类名。<br>一般，如果要把如下中的类b删除<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"a b c"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>代码如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"a b c"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>)[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> className = div.className.split(<span class="regexp">/\s+/</span>);</span><br><span class="line"><span class="built_in">console</span>.log(className);</span><br><span class="line"><span class="keyword">var</span> pos = -<span class="number">1</span>,</span><br><span class="line">i,</span><br><span class="line">len;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>,len = className.length; i&lt; len ;i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(className[i] = <span class="string">"b"</span>)&#123;</span><br><span class="line">		pos = i;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">className.splice(i, <span class="number">1</span>);</span><br><span class="line">div.className = className.join(<span class="string">" "</span>);</span><br><span class="line"><span class="built_in">console</span>.log(div.className);</span></span><br></pre></td></tr></table></figure></p>
<p>可以有更简单且更安全的方法：HTML5新增的一种操作类名的方式，就是为每个元素添加classList属性。<br>classList是集合DOMTokenList的实例。类似NodeList。<br>当然就可以用item()方法来访问了。<br>同时还定义几个方法：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">add(value)</td>
<td style="text-align:left">给定的字符串组添加到列表中。</td>
</tr>
<tr>
<td style="text-align:left">contains(value)</td>
<td style="text-align:left">检测列表中是否存在value类，返回布尔值。</td>
</tr>
<tr>
<td style="text-align:left">remove(value)</td>
<td style="text-align:left">显而易见的意思</td>
</tr>
<tr>
<td style="text-align:left">toggle(value)</td>
<td style="text-align:left">存在就删除，不存在就添加。</td>
</tr>
</tbody>
</table>
<p>所以，可见，之前很多行代码可以使用一行就解决了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>)[<span class="number">1</span>].classList.remove(<span class="string">"b"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(div); <span class="comment">//undefined,说明没有返回值。</span></span><br></pre></td></tr></table></figure></p>
<p>###11.3.2 焦点管理<br>H5添加富足管理DOM焦点的功能:document.<strong>activeElement属性</strong>。<br>元素获得焦点的方式：</p>
<ul>
<li>页面加载</li>
<li>用户输入</li>
<li>调用focus()方法</li>
</ul>
<p>加载期间，activeElement属性是null，加载完之后默认的是document.body。</p>
<p>一个方法：document.hasFocus()，用于确定文档是否获得了焦点。</p>
<h3 id="11-3-3_HTMLDocument的变化">11.3.3 HTMLDocument的变化</h3><h4 id="1-readyState属性">1.readyState属性</h4><p>有两个可能的值：</p>
<ul>
<li>loading</li>
<li>complete</li>
</ul>
<p>这个属性最好的用法就是用来判断文档是否加载完全。<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">document</span>.readyState == <span class="string">"complete"</span>)&#123;xxx&#125;</span><br></pre></td></tr></table></figure></p>
<p>####2.兼容模式<br>区分渲染页面是标准模式还是混合模式，CompatMode属性来判断：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">document</span>.compatMode == <span class="string">"CSS1Compat"</span>)&#123; <span class="comment">//css要大写</span></span><br><span class="line">	alert(<span class="string">"标准模式"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">document</span>.compatMode == <span class="string">"BackCompat"</span>)&#123;</span><br><span class="line">	alert(<span class="string">"混合模式"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>####3.head属性<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> head = <span class="built_in">document</span>.head || <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>];</span><br></pre></td></tr></table></figure></p>
<h3 id="11-3-4_字符集属性">11.3.4 字符集属性</h3><p>charset属性<br>常用的设置UTF-8的操作就是这个。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>可以用document.charset访问到文档中的字符集，默认的是UTF-16。</p>
<h3 id="11-3-5_自定义数据属性">11.3.5 自定义数据属性</h3><p>对于H5页面中自定义的属性，原生js可以通过元素的dataset属性来访问自定义的值。这个属性是<strong>DONStringMap</strong>的实例，是一个名值对的映射。<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"hzhuang"</span> <span class="attribute">data-id</span> = "<span class="attribute">1</span>" <span class="attribute">data-name</span> = "<span class="attribute">hzhuang</span>"&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"hzhuang"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(div);<span class="comment">//DOMStringMap </span></span></span><span class="expression">&#123;<span class="variable">id</span>: <span class="string">"1"</span>, <span class="variable">name</span>: <span class="string">"hzhuang"</span>&#125;</span><span class="xml"><span class="undefined"></span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="11-3-6_插入标记">11.3.6 插入标记</h3><p>####1. innerHTML属性<br>兼容性，有的浏览器返回的标签全变成大写。<br>IE浏览器使用限制：</p>
<ul>
<li>插入script元素必须制定defer属性。</li>
<li>script元素必须位于有作用域的元素之后。script元素在页面中看不见，所以是无作用域的。<br>对于解决方法：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div.innerHTML = "_<span class="tag">&lt;<span class="title">script</span> <span class="attribute">defer</span>&gt;</span><span class="handlebars"><span class="xml">alert('123')\<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="handlebars"><span class="xml">";</span><br><span class="line">div.innerHTML = "<span class="tag">&lt;<span class="title">div</span>&gt;</span>&amp;nbsp;<span class="tag">&lt;<span class="title">script</span> <span class="attribute">defer</span>&gt;</span><span class="handlebars"><span class="xml">alert('123')\<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="handlebars"><span class="xml">";</span><br><span class="line">div.innerHTML = "<span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span> = \"<span class="attribute">hidden</span>\"&gt;</span><span class="tag">&lt;<span class="title">script</span> <span class="attribute">defer</span>&gt;</span><span class="handlebars"><span class="xml">alert('123')\<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="undefined">"; //首选</span></span></span></span></span></span></span></span></span></span></span></span><br></pre></td></tr></table></figure>
<p>对于style就类似了。</p>
<p>还有很多元素是不支持这个属性的，如：head，html，style，表格相关元素，title等……</p>
<p>####2.outerHTML属性<br>与innerHTML相似，但是返回的是包括元素本身的。用于读取或者设置DOM结构。</p>
<p>####3.insertAdjacentHTML()方法<br>接受插入位置和要插入的HTML两个参数。<br>接受插入的位置有四个值：beforebegin，afterbegin，beforeend和afterend。</p>
<table>
<thead>
<tr>
<th style="text-align:left">插入位置</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">beforebegin</td>
<td style="text-align:left">当前元素的前面插入一个紧邻的同辈元素</td>
</tr>
<tr>
<td style="text-align:left">afterend</td>
<td style="text-align:left">当前元素的后面插入一个紧邻的同辈元素</td>
</tr>
<tr>
<td style="text-align:left">afterbegin</td>
<td style="text-align:left">当前元素之下插入一个子元素。第一个子元素之前</td>
</tr>
<tr>
<td style="text-align:left">beforeend</td>
<td style="text-align:left">当前元素之下插入一个子元素。最后的子元素之后</td>
</tr>
</tbody>
</table>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">div</span>.insertAdjacentHTML(<span class="string">"beforebegin"</span>, <span class="string">"hzhuang"</span>);</span><br></pre></td></tr></table></figure>
<p>####4.内存与性能问题<br>使用这些方法设置新的HTML的时候，之前被删掉的还是占用内存的。</p>
<h3 id="11-3-7_scrolltoView()方法。">11.3.7 scrolltoView()方法。</h3><p>通过滚动浏览器窗口或者某个元素，调用元素就可以出现在视口中。</p>
<ul>
<li>传入的参数是true或者没有的话，窗口滚动之后会让调用元素的顶部与视口顶部尽可能齐平。</li>
<li>参数是false，则调用元素会尽可能的出现在视口中。</li>
</ul>
<h2 id="11-4专有扩展">11.4专有扩展</h2><p>就是不同的浏览器自己做的扩展，但是最终在H5中得到标准化。</p>
<p>###11.4.1 文档模式</p>
<p>###11.4.2 children属性<br>解决childNodes属性的差异而诞生的，children属性是HTMLCollection的实例。和childNodes很类似，但是IE9中改进，不包括注释节点。</p>
<p>###11.4.3 contains()方法<br>contains()方法用来检测摸个元素是否有某个后代。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">document</span><span class="class">.documentElement</span><span class="class">.contains</span>(<span class="tag">document</span><span class="class">.body</span>);</span><br></pre></td></tr></table></figure></p>
<p>方法并不是只有这一个，<strong>compareDocumentPosition()</strong>也可以做到，这个方法是用于确定两个节点之间的关系。返回的是表示关系的数字。<br>其中参数就是给定的节点。</p>
<table>
<thead>
<tr>
<th style="text-align:left">返回的数字</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">表示两个节点无关</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">给点节点在参考节点的前面</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">给点节点在参考节点的后面</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">给定的节点是包含节点的祖先</td>
</tr>
<tr>
<td style="text-align:left">16</td>
<td style="text-align:left">给点的节点是参考节点的后代</td>
</tr>
</tbody>
</table>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">result</span> = document.documentElement.compareDocumentPosition(document.body);</span><br><span class="line">console.log(<span class="literal">result</span>);//<span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>通用的contains函数：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">contains</span><span class="params">(resNode, otherNode)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">typeof</span> refNode.contains  == <span class="string">"function"</span> &amp;&amp; (!client.engine.webkit || client.engine.webkit &gt;=<span class="number">552</span>) )&#123;</span><br><span class="line">		<span class="keyword">return</span> resNode.contains(otherNode);</span><br><span class="line"> 	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(type compareDocumentPosition == <span class="string">"function"</span>)&#123;</span><br><span class="line"> 		<span class="keyword">return</span> !!(refNode.compareDocumentPosition(other) &amp; <span class="number">16</span>);<span class="comment">//</span></span><br><span class="line"> 		<span class="comment">//!!(x)的作用是如果x是nuu或者undefined的话，返回的是false。</span></span><br><span class="line"> 	&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"> 		<span class="keyword">var</span> node = otherNode.parentNode;</span><br><span class="line"> 		<span class="keyword">do</span>&#123;</span><br><span class="line"> 			<span class="keyword">if</span>(node === refNode)&#123;</span><br><span class="line"> 				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> 			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> 				node = node.parentNode;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;<span class="keyword">while</span>(node !== <span class="literal">null</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="11-4-4_插入文本">11.4.4 插入文本</h3><p>innerText和outerText没有被纳入H5的规范。</p>
<h3 id="11-4-5_滚动">11.4.5 滚动</h3><p>几个扩展的方法：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">scrollToViewIfNeeded(alignCeter)</td>
<td style="text-align:left">只有在当前的元素在视口中不可见的情况下，才滚动</td>
</tr>
<tr>
<td style="text-align:left">scrollByLines(lineCount)</td>
<td style="text-align:left">将元素的内容滚动到指定的行高</td>
</tr>
<tr>
<td style="text-align:left">scrollByPages(pageCount)</td>
<td style="text-align:left">将元素的内容滚动到指定的页面高度</td>
</tr>
</tbody>
</table>
<h1 id="第12章_DOM2和DOM3">第12章 DOM2和DOM3</h1><p>引入了更多的交互能力功能以模块的方式引入。<br>模块：<br>  核心++视图++事件++样式++遍历和范围++HTMl</p>
<h2 id="12-1_DOM变化">12.1 DOM变化</h2><p>检测浏览是否支持DOM模块，可以使用上章中的检测方法。<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.implementation.hasFeature(<span class="string">"views"</span>, <span class="string">"2.0"</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h3 id="21-1-1_针对XML命名空间的变化">21.1.1 针对XML命名空间的变化</h3><p>####1 node类型的变化</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">localName</td>
<td style="text-align:left">不带命名空间前缀的节点名称</td>
</tr>
<tr>
<td style="text-align:left">nameSpaceURL</td>
<td style="text-align:left">命名空间URL或者null</td>
</tr>
<tr>
<td style="text-align:left">prefix</td>
<td style="text-align:left">命名空间前缀</td>
</tr>
</tbody>
</table>
<p>DOM3中</p>
<p>#第25章 新兴的API<br>内容：</p>
<ul>
<li>创建平滑的动画</li>
<li>操作文件</li>
<li>使用Web Workers在后台执行Js</li>
</ul>
<h2 id="25-1_requestAnimationFrame(_)">25.1 requestAnimationFrame( )</h2><h3 id="早期动画循环">早期动画循环</h3><p>使用setInterval( )来实现。<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">function</span><span class="list">()</span><span class="collection">&#123;</span><br><span class="line">	function updateAnimation<span class="list">()</span><span class="collection">&#123;</span><br><span class="line">		doAnimation1<span class="list">()</span><span class="comment">;</span></span><br><span class="line">		doAnimation2<span class="list">()</span><span class="comment">;</span></span><br><span class="line">	&#125;</span><span class="comment">;</span></span><br><span class="line">	setInterval<span class="list">(<span class="keyword">updateAnimation</span>, <span class="number">100</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;</span>)</span><span class="list">()</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>问题：<br>setInterval( )和setTimeout( )都不是十分的精确。传入第二个参数，实际只是指定了把动画代码添加到浏览器UI线程队列中<strong>以等待执行的时间</strong>。如果队列的前面已经加入了其他任务，那动画代码就要等前面的任务完成后再执行。</p>
<p>###25.1.2 循环间隔的问题<br>浏览器的计数器的精度：各不相同。<br>IE9+:4ms/Firefox+safari:10ms/chrome:4ms<br>所以在不同的浏览器中即使设置相同时间的等待时间，性能也会有区别。</p>
<h3 id="25-1-3_mozRequestAnimationFrame">25.1.3 mozRequestAnimationFrame</h3><p>css变换和动画的优势在于浏览器知道动画什么时候开始，因此会计算出正确的循环讲个。<br>mozRequestAnimationFrame( )告诉浏览区某些js代码要执行动画。它接受一个参数，即在重绘屏幕前调用的一个函数。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">继续</span><br></pre></td></tr></table></figure></p>
<h2 id="25-2_Page_Visibility_API">25.2 Page Visibility API</h2><p>为了让开发人员知道页面是否对用户可见而推出的。</p>
<table>
<thead>
<tr>
<th style="text-align:left">API组成部分</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">document.hidden</td>
<td style="text-align:left">页面是否隐藏的布尔值。页面隐藏包括页面在后台标签或者浏览器最小化。</td>
</tr>
<tr>
<td style="text-align:left">document.visibilityState</td>
<td style="text-align:left">4个可能的值：后台或者最小化、前台标签页中、实际的页面已经隐藏，但是 用户可以预览页面和页面在屏幕外执行预渲染处理。</td>
</tr>
<tr>
<td style="text-align:left">visibilitychange事件</td>
<td style="text-align:left">文档从可见变成不可见或从不可见变成可见时，触发该事件。</td>
</tr>
</tbody>
</table>
<p>此API只有IE10和chrome支持，检测的代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isHiddenSupported</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">typeof</span>(<span class="built_in">document</span>.hidden || <span class="built_in">document</span>.msHidden || <span class="built_in">document</span>.webkitHidden) != <span class="string">"undefined"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleVisibilityChange</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> output = <span class="built_in">document</span>.getElementById(<span class="string">"output"</span>);</span><br><span class="line">	<span class="keyword">var</span> msg;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">document</span>.hidden || <span class="built_in">document</span>.msHidden || <span class="built_in">document</span>.webkitHidden)&#123;</span><br><span class="line">		msg = <span class="string">"hidden"</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		msg = <span class="string">"visibility"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	output.innerHTML += msg;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//EventUtil.addHandler是base.js中得到的。</span></span><br><span class="line">EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">"msvisibilitychange"</span>, handleVisibilityChange);</span><br><span class="line">EventUtil.addhandler(<span class="built_in">document</span>, <span class="string">"webkitvisibilitychange"</span>, handleVisibilityChange);</span><br></pre></td></tr></table></figure></p>
<p>对于document.visibilityState，IE的值和chrome的值是不一样的，chrome是三个：“hidden”,”visible”,”prerender”。IE暂时忽略，</p>
<h2 id="25-3_Geolocation_API">25.3 Geolocation API</h2><p>访问之前 必须要得到用户的明确许可，在页面中共享其位置信息。<br><strong>navigator.geolocation对象</strong>，这个对象包含三个方法：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">用法参数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">getCurrentPosition( )</td>
<td style="text-align:left">触发请求用户共享地理定位信息的对话框。</td>
<td style="text-align:left">三个参数：成功回调函数，可选的失败回调函数以及可选的选项对象。</td>
</tr>
<tr>
<td style="text-align:left">watchPosition( )</td>
<td style="text-align:left">跟踪用户的信息</td>
<td style="text-align:left">参数和上一个完全相同</td>
</tr>
<tr>
<td style="text-align:left">clearWatch( )</td>
<td style="text-align:left">用于取消watchPosition( )的监控</td>
<td style="text-align:left">xx</td>
</tr>
</tbody>
</table>
<p>成功回调函数会接受到一个Position对象参数；Position对象有两个属性：<strong>coords</strong>和<strong>timestamp</strong>。<br>coords包含的信息：</p>
<ul>
<li>latitude：十进制的形式表示的维度</li>
<li>longitude: 十进制的形式表示的经度</li>
<li>accuracy：精度</li>
<li>其他浏览器还有……</li>
</ul>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">navigator.geolocation.getCurrentPosition(<span class="function"><span class="keyword">function</span><span class="params">(position)</span></span>&#123;</span><br><span class="line">	logdrawMapCenteredAt(<span class="keyword">position</span>.coords.latitude,<span class="keyword">position</span>.coords.longitude);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>失败回调函数，返回的是一个对象，有<strong>message</strong>和<strong>code</strong>两个属性。message中的信息解释为什么错误；code属性是一个数组，表示的是错误的类型。<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">navigator.geolocation.getCurrentPosition(<span class="function"><span class="keyword">function</span><span class="params">(position)</span></span>&#123;</span><br><span class="line">	logdrawMapCenteredAt(<span class="keyword">position</span>.coords.latitude,<span class="keyword">position</span>.coords.longitude);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span><span class="params">(error)</span></span>&#123;</span><br><span class="line">	console.<span class="built_in">log</span>(error.message);</span><br><span class="line">	console.<span class="built_in">log</span>(error.code);</span><br><span class="line">&#125;,&#123;</span><br><span class="line">	enableHigeAccuracy: true,</span><br><span class="line">	timeout: <span class="number">5000</span>,</span><br><span class="line">	maximumAge: <span class="number">25000</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>第三个参数用于设定信息的类型。是一个选项对象。</p>
<ul>
<li>enableHighAccuracy是一个boolean值，表示必须尽肯呢个的使用最准确的位置信息。</li>
<li>timeout表示等待位置信息的最长时间。</li>
<li>maximumAge表示上一次取得坐标信息的有效时间。</li>
</ul>
<blockquote>
<p>watchPosition( )起到定时调用getCurrentPosition( )的效果。</p>
</blockquote>
<p>watchPosition( )返回一个数值标识符。如果要取消监控，则使用clearWatch( )方法。</p>
<p>##25.4 File API<br>在文职输入字段的基础上，添加一些直接访问文件信息的接口。H5在DOM中为文件输入元素添加了一个files集合，files集合中包含一组<strong>File对象</strong>，每个File对象就对应着一个文件。<br>File对象的只读属性：</p>
<ul>
<li>name</li>
<li>size</li>
<li>type</li>
<li>lastModifiedDate</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> fileLists = <span class="built_in">document</span>.getElementById(<span class="string">"file-lists"</span>);</span><br><span class="line">	EventUtil.addHandler(fileLists, <span class="string">"change"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> files = EventUtil.getTarget(event).files,i=<span class="number">0</span>,len = files.length;</span><br><span class="line">		<span class="keyword">while</span>(i &lt; len)&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(files[i].name + <span class="string">"("</span> + files[i].type + <span class="string">","</span> + files[i].size + <span class="string">"bites)"</span>);</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###25.4.1 FileReader类型<br>读取文件系统提供的方法：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">readAsText(file, encoding)</td>
<td style="text-align:left">以纯文本形式读取文件，将读取到的文本保存在result属性中。</td>
</tr>
<tr>
<td style="text-align:left">readAsDataURL(file)</td>
<td style="text-align:left">读取文件并且以数据URL的形式保存在result中。</td>
</tr>
<tr>
<td style="text-align:left">readAsBinaryString(file)</td>
<td style="text-align:left">读取文件并将一个字符串保存在result属性中。</td>
</tr>
<tr>
<td style="text-align:left">readAsArrayBuffer(file)</td>
<td style="text-align:left">读取文件并将一个包含文件内容的ArrayBuffer保存在result中。</td>
</tr>
</tbody>
</table>
<p>读取文件也是<strong>异步的</strong>，所以也会包括几个事件：</p>
<ul>
<li>progress：获得lengthComputable，loaded和total属性。</li>
<li>error：返回error属性。五种错误。</li>
<li>load：读取成功时候调用。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> fileLists = <span class="built_in">document</span>.getElementById(<span class="string">"file-lists"</span>);</span><br><span class="line">	EventUtil.addHandler(fileLists, <span class="string">"change"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> info = <span class="string">""</span>,</span><br><span class="line">		output = <span class="built_in">document</span>.getElementById(<span class="string">"output"</span>),</span><br><span class="line">		progress = <span class="built_in">document</span>.getElementById(<span class="string">"progress"</span>),</span><br><span class="line">		files = EventUtil.getTarget(event).files,</span><br><span class="line">		type = <span class="string">"default"</span>,</span><br><span class="line">		reader = <span class="keyword">new</span> FileReader();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(<span class="regexp">/image/</span>.test(files[<span class="number">0</span>].type))&#123;</span><br><span class="line">			reader.readAsDataURL(files[<span class="number">0</span>]);</span><br><span class="line">			type = <span class="string">"image"</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			reader.readAsText(files[<span class="number">0</span>]);</span><br><span class="line">			type = <span class="string">"text"</span>;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		reader.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			output.innerHTML = <span class="string">"Could not read file, error code is "</span> + reader.error.code;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		reader.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(event.lengthComputable)&#123;</span><br><span class="line">				progress.innerHTML = event.loaded + <span class="string">"/"</span> + event.total;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">var</span> html = <span class="string">""</span>;</span><br><span class="line">			<span class="keyword">switch</span>(type)&#123;</span><br><span class="line">				<span class="keyword">case</span> <span class="string">"image"</span>:</span><br><span class="line">				html = <span class="string">"&lt;img src=\""</span> + reader.result + <span class="string">"\"&gt;"</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="string">"text"</span>:</span><br><span class="line">				heml = reader.result;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			output.innerHTML = html;</span><br><span class="line">			<span class="built_in">console</span>.log(reader.result);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>abort( )方法可以停止以上过程。</p>
<p>###25.4.2 读取部分内容<br>如果想读取文件的部分内容，File对象还支持一个slice( )方法。在火狐浏览器中加入moz，在chrome中要加入webkit。<br>slice( )支持两个参数：第一个起始字节，第二个是读取的字节数。<br><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">blobSlice</span><span class="params">(blob, startByte, length)</span>&#123;</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="transposed_variable">blob.</span>slice)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="transposed_variable">blob.</span>slice(startByte, <span class="built_in">length</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="transposed_variable">blob.</span>webkit)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="transposed_variable">blob.</span>webkitSlice(startByte, <span class="built_in">length</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="transposed_variable">blob.</span>mozslice)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="transposed_variable">blob.</span>mozSlice(startByte, <span class="built_in">length</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> null;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Blob类型有一个size属性和type属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> fileLists = <span class="built_in">document</span>.getElementById(<span class="string">"file-lists"</span>);</span><br><span class="line">	EventUtil.addHandler(fileLists, <span class="string">"change"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> info = <span class="string">""</span>,</span><br><span class="line">		output = <span class="built_in">document</span>.getElementById(<span class="string">"output"</span>),</span><br><span class="line">		progress = <span class="built_in">document</span>.getElementById(<span class="string">"progress"</span>),</span><br><span class="line">		files = EventUtil.getTarget(event).files,</span><br><span class="line">		type = <span class="string">"default"</span>,</span><br><span class="line">		reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">		blob = blobSlice(files[<span class="number">0</span>], <span class="number">0</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(blob)&#123;</span><br><span class="line">			reader.readAsText(blob);</span><br><span class="line"></span><br><span class="line">			reader.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">				output.innerHTML = <span class="string">"Could not read file, error code is "</span> + reader.error.code;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			reader.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(event.lengthComputable)&#123;</span><br><span class="line">					progress.innerHTML = event.loaded + <span class="string">"/"</span> + event.total;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">				<span class="keyword">var</span> html = <span class="string">""</span>;</span><br><span class="line">				<span class="keyword">switch</span>(type)&#123;</span><br><span class="line">					<span class="keyword">case</span> <span class="string">"image"</span>:</span><br><span class="line">					html = <span class="string">"&lt;img src=\""</span> + reader.result + <span class="string">"\"&gt;"</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="string">"text"</span>:</span><br><span class="line">					heml = reader.result;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				output.innerHTML = html;</span><br><span class="line">				<span class="built_in">console</span>.log(reader.result);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			alert(<span class="string">"Your browser doesn't support slice()."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">blobSlice</span>(<span class="params">blob, startByte, length</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(blob.slice)&#123;</span><br><span class="line">		<span class="keyword">return</span> blob.slice(startByte, length);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(blob.webkit)&#123;</span><br><span class="line">		<span class="keyword">return</span> blob.webkitSlice(startByte, length);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(blob.mozslice)&#123;</span><br><span class="line">		<span class="keyword">return</span> blob.mozSlice(startByte, length);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###25.4.3 对象URL</p>

      
    </div>

    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/高级程序/">高级程序</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    
<article id="post-selector" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/18/selector/" class="article-date">
  	<time datetime="2015-06-18T14:23:30.000Z" itemprop="datePublished">2015-06-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/18/selector/">css之选择器(selector)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
<a href="https://unsplash.it/1568/500/?random" title="" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://unsplash.it/1568/500/?random" title=""></a>

      <div class="entry">
      
        <h1 id="css3选择器分类">css3选择器分类</h1><ul>
<li>基本选择器</li>
<li>层次选择器</li>
<li>伪类选择器</li>
<li>伪元素</li>
<li>属性选择器</li>
</ul>
<p>其中最为复杂的是伪类选择器。<br>以下是css3选择器的分类图<br><img src="http://hz2015.sinaapp.com/static/pictures/selector-strucate.jpg" alt=""><br>
      
    </div>

    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css3/">css3</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/learning/">learning</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/选择器/">选择器</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/06/18/selector/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 hzhuang
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>