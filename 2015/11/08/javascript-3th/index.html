<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>javascript高级程序设计第三版笔记（持续更新） | hzhuang的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="article">
<meta property="og:title" content="javascript高级程序设计第三版笔记（持续更新）">
<meta property="og:url" content="http://huangzhuang.github.io/2015/11/08/javascript-3th/index.html">
<meta property="og:site_name" content="hzhuang的博客">
<meta property="og:description">
<meta property="og:image" content="http://hz2015.sinaapp.com/static/pictures/gjcx.jpg">
<meta property="og:updated_time" content="2015-11-08T13:54:30.475Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="javascript高级程序设计第三版笔记（持续更新）">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="hzhuang的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://hz2015.sinaapp.com/static/images/zhuang.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">hzhuang</a></h1>
		</hgroup>

		
		<p class="header-subtitle">人若无名，便可专心练剑！</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags/css3">css3</a></li>
				        
							<li><a href="/tags/js">javascript</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/huangzhuang" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/1875236755/profile?topnav=1&wvr=6" title="weibo">weibo</a>
					        
								<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/huang-zhuang-225" title="zhihu">zhihu</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/MVC/" style="font-size: 10px;">MVC</a> <a href="/tags/animation/" style="font-size: 10px;">animation</a> <a href="/tags/autosize/" style="font-size: 10px;">autosize</a> <a href="/tags/codewars/" style="font-size: 10px;">codewars</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/css3/" style="font-size: 16px;">css3</a> <a href="/tags/iscroll/" style="font-size: 10px;">iscroll</a> <a href="/tags/js/" style="font-size: 20px;">js</a> <a href="/tags/js-sdk/" style="font-size: 10px;">js-sdk</a> <a href="/tags/learning/" style="font-size: 14px;">learning</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/reqexp/" style="font-size: 10px;">reqexp</a> <a href="/tags/transition/" style="font-size: 10px;">transition</a> <a href="/tags/代码规范/" style="font-size: 12px;">代码规范</a> <a href="/tags/前端/" style="font-size: 18px;">前端</a> <a href="/tags/前端框架/" style="font-size: 10px;">前端框架</a> <a href="/tags/学习笔记/" style="font-size: 10px;">学习笔记</a> <a href="/tags/录音/" style="font-size: 10px;">录音</a> <a href="/tags/模仿qq/" style="font-size: 10px;">模仿qq</a> <a href="/tags/笔记/" style="font-size: 10px;">笔记</a> <a href="/tags/简书/" style="font-size: 10px;">简书</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a> <a href="/tags/选择器/" style="font-size: 10px;">选择器</a> <a href="/tags/高级程序/" style="font-size: 10px;">高级程序</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">华中科技大学13级硕士，在读。想从事前端类工作，努力奋进中。。。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">hzhuang</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://hz2015.sinaapp.com/static/images/zhuang.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">hzhuang</h1>
			</hgroup>
			
			<p class="header-subtitle">人若无名，便可专心练剑！</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/css3">css3</a></li>
		        
					<li><a href="/tags/js">javascript</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/huangzhuang" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/1875236755/profile?topnav=1&wvr=6" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/huang-zhuang-225" title="zhihu">zhihu</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-javascript-3th" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/08/javascript-3th/" class="article-date">
  	<time datetime="2015-11-08T13:54:30.475Z" itemprop="datePublished">2015-11-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      javascript高级程序设计第三版笔记（持续更新）
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/高级程序/">高级程序</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="http://hz2015.sinaapp.com/static/pictures/gjcx.jpg" alt=""></p>
<a id="more"></a>
<p>#目录</p>
<ul>
<li><p>第三章</p>
<ul>
<li>3.1 语法</li>
<li>3.4 数据类型</li>
<li>3.5 操作符</li>
<li>3.6 语句</li>
<li>3.7 函数</li>
</ul>
</li>
<li><p>第五章 <a href="#第五章_引用类型">引用类型</a></p>
<ul>
<li>5.2 <a href="#5-2_数组类型">数组类型</a></li>
<li>5.3 <a href="#5-3_Date类型">Date类型</a></li>
</ul>
</li>
<li><p>第六章 <a href="#第六章_面向对象的程序设计">面向对象程序设计</a></p>
<ul>
<li>6.1 <a href="#6-1_理解对象">理解对象</a></li>
<li>6.2 <a href="#6-2_创建对象">创建对象</a></li>
<li>6.3 <a href="#6-3_继承">继承</a></li>
</ul>
</li>
<li>第七章 <a href="#第七章_函数表达式">函数表达式</a><ul>
<li>7.1 <a href="#7-1_递归">递归</a></li>
<li>7.2 <a href="#7-2_闭包">闭包</a></li>
<li>7.3 <a href="#7-3_模仿块级作用域">模仿块级作用域</a></li>
</ul>
</li>
<li>第八章 <a href="#第八章_BOM">BOM</a><ul>
<li>8.1 <a href="#8-1_window对象">window对象</a></li>
<li>8.2 <a href="#8-2_location对象">location对象</a></li>
<li>8.3 <a href="#8-3_navigator对象">navigator对象</a></li>
<li>8.5 <a href="#8-5_history对象">history对象</a></li>
</ul>
</li>
<li>第二十五章 <a href="#第25章_新兴的API">新兴的API</a><ul>
<li>25.1 <a href="#25-1_requestAnimationFrame(">requestAnimationFrame( )</a>)</li>
<li>25.2 <a href="#25-2_Page_Visibility_API">Page Visibility API</a></li>
<li>25.3 <a href="#25-3_Geolocation_API">Geolocation API</a></li>
<li>25.4 <a href="#25-4_File_API">File API</a></li>
</ul>
</li>
</ul>
<hr>
<p>#第二章 javascript简介</p>
<ul>
<li>netscape创建LiveScript脚本语言。搭java顺风车就改为javascript。</li>
<li>js三部分：ECMAScript，dom，bom</li>
<li>script标签的defer和async属性只针对外部文件，一般不用，没有这两者的时候，就会按照在页面中出现的位置先后执行的。</li>
<li>js文件放在html外部的优势：可维护性，可缓存，适应未来。</li>
<li>如果浏览器不支持javascript，那么可以用noscript标签来写出替代说明文字。</li>
</ul>
<hr>
<p>#第三章 基本概念</p>
<p>##3.1 语法</p>
<ul>
<li>区分大小写</li>
<li>标识符</li>
<li>注释<br>单行（//） 多行（/<em>  </em>/）</li>
<li>严格模式 use strict<br>javascript的一种不同的解析与执行模型。一些不确定的行为将得到处理以及某些不安全的操作会抛出错误。</li>
<li>语句</li>
</ul>
<p>##3.2 关键字和保留字<br>全部关键字：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>，<span class="keyword">case</span>，catct，<span class="keyword">continue</span>，<span class="keyword">debugger</span>，<span class="keyword">default</span>，<span class="keyword">delete</span>，<span class="keyword">do</span>，<span class="keyword">else</span>，<span class="keyword">finally</span>，<span class="keyword">for</span>，<span class="keyword">function</span>，<span class="keyword">if</span>，<span class="keyword">in</span>，<span class="keyword">instanceof</span>，<span class="keyword">new</span>，<span class="keyword">return</span>，<span class="keyword">switch</span>，<span class="keyword">this</span>，<span class="keyword">throw</span>，<span class="keyword">try</span>，<span class="keyword">typeof</span>，<span class="keyword">var</span>，<span class="literal">void</span>，<span class="keyword">while</span>，<span class="keyword">with</span></span><br></pre></td></tr></table></figure></p>
<p>##3.4 数据类型</p>
<ul>
<li>五个基本的数据类型：<br>string,number,boolean,null,undefined</li>
<li>一个复杂类型：<br>object</li>
</ul>
<p>###3.4.1 typeof操作符<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> huang = <span class="string">"hzhaung"</span>;</span><br><span class="line"><span class="keyword">var</span> zhuang=<span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(huang)); <span class="comment">//string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="number">95</span>)); <span class="comment">//number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="number">1</span> == <span class="number">2</span>)); <span class="comment">//booleam</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(a)); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(zhuang)); <span class="comment">//object    原因:null是被认为是一个空的对象指针</span></span><br></pre></td></tr></table></figure></p>
<p>###3.4.2 Undefined类型<br>未申明的变量以及为初始化的变量都是undefined。</p>
<p>###3.4.3 null类型<br>null值表示一个空的对象指针。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> 返回<span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>注意的是一般设置变量为null是为了用这个变量来保存对象，故而要写出var xx=null。</p>
<p>###3.4.4 boolean类型</p>
<ul>
<li>false，””，0+NAN，null，undefined都是false。换句话说就是其他的都是true了。</li>
<li>区别大小写。</li>
</ul>
<p>###3.4.5 number类型<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> num1</span> = <span class="number">070</span>; <span class="comment">//八进制</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> num2</span> = <span class="number">0xA</span>; <span class="comment">//十六进制</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> num3</span> = <span class="number">10</span>; <span class="comment">//十进制</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>NUMBER.MIN_VALUE或者NUMBER.MAX_VALUE超出就会自动转换成infinity，如果是负的就在前面加上-。</li>
</ul>
<p>ifFinity( ):判断数值是否在有限数值范围内，true表示在，false表示不在。</p>
<p>NaN(not a number)</p>
<ul>
<li>任意涉及NaN的操作都会返回NaN;</li>
<li>NaN与任何值都不相等，包含NaN本身。</li>
</ul>
<p>isNaN( ):接受参数后会将其转化成数值，不能转化的话就会返回true。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">"huang"</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">true</span>));  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>));  <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>数值转换:</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">作用对象</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Number( )</td>
<td style="text-align:left">可用于任何数据类型</td>
</tr>
<tr>
<td style="text-align:left">parseInt( )</td>
<td style="text-align:left">针对字符串</td>
</tr>
<tr>
<td style="text-align:left">parseFloat( )</td>
<td style="text-align:left">针对字符串</td>
</tr>
</tbody>
</table>
<p>Number的转换规则：</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">boolean</td>
<td style="text-align:left">false-0;true-1</td>
</tr>
<tr>
<td style="text-align:left">number</td>
<td style="text-align:left">简单的传入换个返回</td>
</tr>
<tr>
<td style="text-align:left">null</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">undefined</td>
<td style="text-align:left">NaN</td>
</tr>
<tr>
<td style="text-align:left">string</td>
<td style="text-align:left">“123”-123；“1.1”-1.1；“0xf”-15；“”-0；其他-NaN）</td>
</tr>
<tr>
<td style="text-align:left">object</td>
<td style="text-align:left">调用valueOf( ),然后依照前面的规则</td>
</tr>
<tr>
<td style="text-align:left">NaN</td>
<td style="text-align:left">调用toString( ),然后依照前面的规则</td>
</tr>
</tbody>
</table>
<p>parseInt( )示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"1234blue"</span>)); <span class="comment">//1234</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"0xA"</span>)); <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"22.5"</span>)); <span class="comment">//22</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseInt</span>(<span class="string">"10"</span>,<span class="number">2</span>); <span class="comment">//2</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">"10"</span>,<span class="number">8</span>); <span class="comment">//8</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">"10"</span>,<span class="number">10</span>); <span class="comment">//10</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">"10"</span>,<span class="number">16</span>); <span class="comment">//16</span></span><br></pre></td></tr></table></figure></p>
<p>###3.4.6 String类型</p>
<ul>
<li>toString( )除null和undefined,因为他们没有这个方法。一般是不用参数的，可以加一个参数来表示数值的基数。</li>
<li>String( )规则：null返回”null”,undefined返回“undefined”。（在不知道要转化的值是不是null或者undefined）</li>
</ul>
<p>###3.4.7 Object类型<br>一组数据和功能的集合。每个实例具有以下的属性和方法。对象是实例的基础。</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Constructor</td>
<td style="text-align:left">保存用于创建当前对象的函数，构造函数</td>
</tr>
<tr>
<td style="text-align:left">hasOwnproperty（propertyName）</td>
<td style="text-align:left">检查给定的属性在当前的实例中是否存在。<strong>不是</strong>在实例的原型中。</td>
</tr>
<tr>
<td style="text-align:left">isPrototypeof（object）</td>
<td style="text-align:left">检查对象是否是另一个对象的原型。</td>
</tr>
<tr>
<td style="text-align:left">propertyIsEnumerable</td>
<td style="text-align:left">检查是否可以用for-in来枚举。</td>
</tr>
<tr>
<td style="text-align:left">toLocaleString( )</td>
<td style="text-align:left">返回对象的字符串表示。</td>
</tr>
<tr>
<td style="text-align:left">toString( )</td>
<td style="text-align:left">返回对象的字符串表示。</td>
</tr>
<tr>
<td style="text-align:left">valueOf( )</td>
<td style="text-align:left">返回对象的字符串，数值或布尔值表示，通常和上个方法的返回值相同。</td>
</tr>
</tbody>
</table>
<p>##3.5 操作符<br>在对对象使用操作符的时候，要调用valueOf( )或toString( )来获得可以操作的值。</p>
<p>###3.5.1 一元操作符<br> 一元操作符：++，–，+，-。前置和后置的区别：前置的时候语句也改变。<br>递增和递减操作符的规则如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"1"</span>;</span><br><span class="line"><span class="keyword">var</span> str1 = <span class="string">"z"</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> f = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">	valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(++str); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(++str1);<span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(++b); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(++f);<span class="comment">//2.1</span></span><br><span class="line"><span class="built_in">console</span>.log(++o);<span class="comment">//0 </span></span><br><span class="line"><span class="comment">//如果是对象，则会先调用valueOf(),然后根据返回的值来确定加减之后的值。</span></span><br></pre></td></tr></table></figure></p>
<p>###3.5.2 位操作符<br>32位，最后一个位表示符号位，0位正1为负。 正数就是常见的，对于负数则是以补码的形式储存（绝对值，反码，加1）。<br>但是输出负数时候这些操作都是隐藏的，输出的时候就是常见负数在前面加符号的形式。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var num = -<span class="number">18</span>;</span><br><span class="line">console.<span class="built_in">log</span>(num.toString(<span class="number">2</span>));<span class="comment">//"-10010"</span></span><br></pre></td></tr></table></figure></p>
<p>对于非数值使用位操作符，则先自动调用Number( )，然后再应用位操作。</p>
<ul>
<li><p>按位非( ~)<br>返回数值的反码:操作数的负数减1。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">num</span> = <span class="number">29</span>;</span><br><span class="line"><span class="keyword">var</span> num1 = ~ <span class="built_in">num</span>;</span><br><span class="line">console.log(num1); <span class="comment">//-26</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>按位与</p>
</li>
<li>按位或</li>
<li>按位异或</li>
<li>左移(&lt;&lt;)<br>移出的空位就以0补充。</li>
<li>右移</li>
</ul>
<p>###3.5.3 布尔操作符<br>1.逻辑非<br>对象-false；空-true；非空-false；0-true；任意非0-false；null-true；NaN-true；undefined-true</p>
<p>2.逻辑与<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">result</span> = <span class="literal">true</span> &amp;&amp; <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></p>
<p>3.逻辑或</p>
<p>###3.5.4 乘性操作符<br>乘法，除法和求模<br>如果有一个不是数值，则会先自动调用number（）之后再返回结果。<br>……</p>
<p>###3.5.5 加性操作符<br><strong>加法</strong>特殊：</p>
<ul>
<li>两个字符串：就拼接起来。</li>
<li>只有一个字符串，则将另一个转换成字符串，然后拼接。</li>
<li>有一个是对象，数值或者布尔值，则调用toString( ),然后再拼接。</li>
<li>对于undefined和null,则调用String( )取到”undefined”和”null”。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="number">5</span>+<span class="string">"5"</span>); <span class="comment">//"55"</span></span><br></pre></td></tr></table></figure>
<p><strong>减法</strong>特殊：<br>不是数值的调用Number( )就OK啦。</p>
<p>###3.5.6 关系操作符<br>规则：如示例代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="number">5</span> &gt; <span class="number">4</span>);<span class="comment">//true</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"h"</span> &gt; <span class="string">"z"</span>) <span class="comment">//false 转换为字符编码比较。</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="number">5</span>&lt;<span class="string">"2"</span>) <span class="comment">//false "2"自动转化成2</span></span><br></pre></td></tr></table></figure></p>
<p>###3.5.7 相等操作符</p>
<table>
<thead>
<tr>
<th style="text-align:left">数据类型</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">一个boolean</td>
<td style="text-align:left">先转化成数值然后再判断</td>
</tr>
<tr>
<td style="text-align:left">string+number</td>
<td style="text-align:left">string转化成数值先</td>
</tr>
<tr>
<td style="text-align:left">对象+非对象</td>
<td style="text-align:left">调用对象的valueOf( )方法，得到的值再比较</td>
</tr>
<tr>
<td style="text-align:left">null+undefined</td>
<td style="text-align:left">相等</td>
</tr>
<tr>
<td style="text-align:left">有NaN</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left">对象+对象</td>
<td style="text-align:left">比较是不是同一个人对象</td>
</tr>
</tbody>
</table>
<p>全等和不全等：</p>
<ul>
<li>===：未经转化的情况下相等才会返回true<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>   -----<span class="literal">true</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span> -----<span class="literal">false</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>###3.5.8 条件操作符<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">variable</span> = boolean<span class="number">_</span>expression ? true<span class="number">_</span><span class="keyword">value</span> : false<span class="number">_</span><span class="keyword">value</span> ;</span><br></pre></td></tr></table></figure></p>
<p>###3.5.9 赋值操作符</p>
<p>###3.5.10 逗号操作符<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var <span class="label">num1</span>,<span class="label">num2</span>,<span class="label">num3</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-6_语句">3.6 语句</h2><p>整理不常用的，if，for就整理啦。</p>
<p>###3.6.2 do-while语句<br>只有在循环体重的代码执行之后，才会测试出口条件。即，循环体内的代码至少会执行一次。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	i += <span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">while</span>(i &lt; <span class="number">10</span>);</span><br></pre></td></tr></table></figure></p>
<p>###3.6.5 for-in 语句<br>一种准确的迭代语句，可以用来枚举对象的属性。</p>
<p>###3.6.6 label语句<br>标签 labe：statement。这个标签可以通过break或者continue来引用，一般与for语句配合使用。</p>
<p>###3.6.7 break和continue语句</p>
<ul>
<li>break会立即退出循环</li>
<li>continue也会立即退出循环，但是退出后会从循环的顶部继续执行。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var no = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(var i= <span class="number">1</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(i % <span class="number">5</span> == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">continue</span>;  </span><br><span class="line">	&#125;</span><br><span class="line">	no++ ;</span><br><span class="line">&#125;</span><br><span class="line">console.<span class="built_in">log</span>(no);<span class="comment">//8</span></span><br><span class="line"></span><br><span class="line">var no = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(var i= <span class="number">1</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(i % <span class="number">5</span> == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">break</span>;  </span><br><span class="line">	&#125;</span><br><span class="line">	no++ ;</span><br><span class="line">&#125;</span><br><span class="line">console.<span class="built_in">log</span>(no);<span class="comment">//4</span></span><br></pre></td></tr></table></figure>
<p>结合label可以说明是退出的那个循环。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var num = <span class="number">0</span>;</span><br><span class="line">outermost:</span><br><span class="line"><span class="keyword">for</span>(var i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(var j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i == <span class="number">5</span> &amp;&amp; j==<span class="number">5</span>)&#123;</span><br><span class="line">			<span class="keyword">break</span> outermost;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###3.6.8 with语句<br>将代码的作用域设置到一个特定的对象中。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">with(location)&#123;</span><br><span class="line">	<span class="variable"><span class="keyword">var</span> gs</span> = search.substring(<span class="number">1</span>);    <span class="comment">//等价于var gs = location.search.substring(1);</span></span><br><span class="line">	<span class="variable"><span class="keyword">var</span> hostName</span> = hostname;</span><br><span class="line">	<span class="variable"><span class="keyword">var</span> url</span> = href;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##3.7 函数</p>
<p>好处：封装，任意时刻调用。</p>
<p>ECMAScript中函数可以通过return语句返回值。执行return后就会停止。如果return语句不带返回的值，则会默认返回undefined。</p>
<p>注：eval和arguments不可以定义为变量。</p>
<p>函数的参数：</p>
<ul>
<li>函数内部的参数是一个数组，arguments对象。   类似array，arguments[0]是合法的，而且也有length属性。故： 在定义函数的时候参数是非必须的，在调用的时候加上参数也不会出问题。这是区别其他语言的。</li>
<li>arguments对象可以和命名的参数一起使用。但是两者的内存空间是不一样的。</li>
</ul>
<p>###3.7.2 没有重载<br>没有重载：由于js函数的特点，则是无法实现重载的，如果存在两个则后取。</p>
<p>#第五章 引用类型</p>
<p>##5.2 Array类型<br>js的数组可以保存任何类型的数据，也可以自动增长。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建方法一：Array构造函数</span></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="comment">//创建长度是20</span></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建方法二：数组字面两表示法。</span></span><br><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"yellow"</span>, <span class="string">"white"</span>];</span><br></pre></td></tr></table></figure></p>
<p>数组不仅仅是可读的。如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];  </span><br><span class="line">colors.length = <span class="number">2</span>;</span><br><span class="line">alert(colors[<span class="number">2</span>]);        <span class="comment">//undefined  第三项移除了</span></span><br></pre></td></tr></table></figure></p>
<p>###5.2.1检测数组<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">	xxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是这种方法是有问题：</p>
<ul>
<li>假定单一的全局执行环境，如果有多个框架，则就会有多个全局执行环境。从而存在多个不同版本的构造函数。</li>
</ul>
<p>改进：<figure class="highlight"><figcaption><span>)```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">```&#10;if(Array.isArray(value))&#123;&#10;&#9;xxx;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>###5.2.1转换方法<br>|转换方法|说明|<br>|:———|:—-|<br>|toLocaleString( )|类似toString( )|<br>|toString( )|会返回由数组中每个值得字符串形式凭借而成的一个以逗号分隔的字符串。|<br>|valueOf( )|返回的还是数值|</p>
<p>eg：<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var colors=[<span class="string">"red"</span>,<span class="string">"blcak"</span>,<span class="string">"white"</span>]</span><br><span class="line">console.<span class="keyword">log</span>(colors.valueOf());//[<span class="string">"red"</span>, <span class="string">"blcak"</span>, <span class="string">"white"</span>]</span><br><span class="line">console.<span class="keyword">log</span>(colors.<span class="keyword">to</span>String());//red,blcak,white</span><br></pre></td></tr></table></figure></p>
<p>join( ):方法讲数组按照（）内的参数连接起来。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> colors</span>=[<span class="string">"red"</span>,<span class="string">"blcak"</span>,<span class="string">"white"</span>]</span><br><span class="line"><span class="variable"><span class="keyword">var</span> test_one</span> = colors.valueOf().join();</span><br><span class="line"><span class="variable"><span class="keyword">var</span> test_two</span> = colors.valueOf().join(<span class="string">"-"</span>);</span><br><span class="line">console.log(test_one);<span class="comment">//red,blcak,white</span></span><br><span class="line">console.log(test_two);<span class="comment">//red-blcak-white</span></span><br></pre></td></tr></table></figure></p>
<p>###5.2.3栈方法<br>数组可以表现的像栈一样，栈是一种可以限制插入和删除项的数据结构。后进先出。</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">push( )</td>
<td style="text-align:left">将参数里面的对象逐个添加到数组中，并返回数组修改后的长度值。</td>
</tr>
<tr>
<td style="text-align:left">pop( )</td>
<td style="text-align:left">与push的作用相反,但是返回值是数组的<strong>最后一项</strong></td>
</tr>
</tbody>
</table>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">var</span> colors=[<span class="string">"red"</span>,<span class="string">"blcak"</span>,<span class="string">"white"</span>]</span><br><span class="line"> console.<span class="function"><span class="title">log</span><span class="params">(colors.push(<span class="string">"huang"</span> , <span class="string">"zhuang"</span>)</span></span>)<span class="comment">//5;</span></span><br></pre></td></tr></table></figure>
<p>###5.2.4 队列方法<br>队列的访问规则是“先进先出”，表现在队列的末端添加项，在队列的前端移除项。</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">shift( )</td>
<td style="text-align:left">移除数组中的第一项，并返回该项</td>
</tr>
<tr>
<td style="text-align:left">unshift( )</td>
<td style="text-align:left">与shift的作用相反,可以在数组的前端添加任意个项并返回数组的长度。</td>
</tr>
</tbody>
</table>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟队列的组合</span></span><br><span class="line"><span class="function"><span class="title">push</span><span class="params">( )</span></span> + <span class="function"><span class="title">shift</span><span class="params">( )</span></span> </span><br><span class="line"><span class="function"><span class="title">unshift</span><span class="params">( )</span></span> + <span class="function"><span class="title">pop</span><span class="params">( )</span></span></span><br></pre></td></tr></table></figure>
<p>###5.2.5 重排序方法<br>|方法|功能|<br>|:—-|:—-|<br>|reverse( )|反转数组项的排序|<br>|sort( )|按照升序的方法排列数组项，会调用每个项的toString( )转型方法，比较的是<strong>字符串</strong>|</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort( );</span><br><span class="line">console.<span class="built_in">log</span>(values);<span class="comment">//[0, 1, 10, 15, 5]因为是比较的字符串，所以5在最后。</span></span><br></pre></td></tr></table></figure>
<p>可见以上的sort( ）的方法不够完美。<br>sort( )可以接受<em>一个比较函数</em>作为参数来完善不足。<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> compare(<span class="keyword">value</span><span class="number">1</span>, <span class="keyword">value</span><span class="number">2</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">value</span><span class="number">1</span> - <span class="keyword">value</span><span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">values.sort(compare);</span><br><span class="line">console.log(values);<span class="comment">//[0, 1, 5, 10, 15]</span></span><br></pre></td></tr></table></figure></p>
<p>可见，完美解决，达到排序的效果。</p>
<p>###5.2.6 操作方法<br>|方法|功能|<br>|:—-|:—-|<br>|concat( )|基于当前数组中的所有项创建一个新的数组（副本），然后将接受到的参数添加到这个副本的末尾。|<br>|slice( )|基于当前的数组中的一个或者多个创建一个新的数组|<br>|splice( )|向数组的中部插入项。|<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// <span class="atom">concat</span></span><br><span class="line"><span class="atom">var</span> <span class="atom">colors</span> = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"yellow"</span>];</span><br><span class="line"><span class="atom">var</span> <span class="atom">color_new</span> = <span class="atom">colors</span>.<span class="atom">concat</span>(<span class="string">"huang"</span>,[<span class="string">"zhuang"</span>,<span class="string">"hz"</span>]);</span><br><span class="line"><span class="atom">console</span>.<span class="atom">log</span>(<span class="atom">color_new</span>);//[<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"yellow"</span>, <span class="string">"huang"</span>, <span class="string">"zhuang"</span>, <span class="string">"hz"</span>]</span><br><span class="line"></span><br><span class="line">// <span class="atom">slice</span></span><br><span class="line">// 接受一个或者两个参数指定位置开始和到当前数组末尾的所有项。不会影响原始数组。</span><br><span class="line"><span class="atom">var</span> <span class="atom">colors</span> = [<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>,<span class="string">"yellow"</span>,<span class="string">"purple"</span>];</span><br><span class="line"><span class="atom">var</span> <span class="atom">colors2</span> = <span class="atom">colors</span>.<span class="atom">slice</span>(<span class="number">1</span>);</span><br><span class="line"><span class="atom">console</span>.<span class="atom">log</span>(<span class="atom">colors2</span>);//[<span class="string">"green"</span>, <span class="string">"blue"</span>, <span class="string">"yellow"</span>, <span class="string">"purple"</span>]</span><br><span class="line"><span class="atom">var</span> <span class="atom">colors3</span> = <span class="atom">colors</span>.<span class="atom">slice</span>(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line"><span class="atom">console</span>.<span class="atom">log</span>(<span class="atom">colors3</span>);//[<span class="string">"green"</span>, <span class="string">"blue"</span>, <span class="string">"yellow"</span>]</span><br></pre></td></tr></table></figure></p>
<p>splice( )详解：<br>1.删除<br>可以删除任意数量的项，指定两个参数：要删除的第一项的位置和要删除的项数。会返回删除的项。返回的是一个数组。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var colors = [<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>,<span class="string">"yellow"</span>,<span class="string">"purple"</span>];</span><br><span class="line">var <span class="built_in">remove</span> = colors.splice(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">console.<span class="built_in">log</span>(colors);//[<span class="string">"blue"</span>, <span class="string">"yellow"</span>, <span class="string">"purple"</span>]</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">remove</span>);//<span class="string">"red"</span>, <span class="string">"green"</span>]</span><br></pre></td></tr></table></figure></p>
<p>2.插入<br>可以添加任意数量的项，提供3个参数，起始位置，0和要插入的项。<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var removed = colors.<span class="keyword">splice</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="string">"huang"</span>,<span class="string">"zhuang"</span>);</span><br><span class="line">console.<span class="keyword">log</span>(colors);<span class="regexp">//</span>[<span class="string">"blue"</span>, <span class="string">"huang"</span>, <span class="string">"zhuang"</span>, <span class="string">"yellow"</span>, <span class="string">"purple"</span>]</span><br><span class="line">console.<span class="keyword">log</span>(removed);<span class="regexp">//</span>[ ]</span><br></pre></td></tr></table></figure></p>
<p>3.替换<br>可以在指定的地方出入任意数量的项，同事删除任意数量的项。<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var removed = colors.<span class="keyword">splice</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"huang"</span>,<span class="string">"zhuang"</span>);</span><br><span class="line">console.<span class="keyword">log</span>(colors);<span class="regexp">//</span>[<span class="string">"blue"</span>, <span class="string">"huang"</span>, <span class="string">"zhuang"</span>, <span class="string">"zhuang"</span>, <span class="string">"yellow"</span>, <span class="string">"purple"</span>]</span><br><span class="line">console.<span class="keyword">log</span>(removed);<span class="regexp">//</span>[<span class="string">"huang"</span>]</span><br></pre></td></tr></table></figure></p>
<p>发现：</p>
<ul>
<li>splice( )始终会返回一个数组。</li>
<li>返回的数组包含从原始数组中删除的项，如果没有删除过，就会返回一个空数组。</li>
</ul>
<p>###5.2.7 位置方法<br>|方法|功能|<br>|:—-|:—-|<br>|indexOf( )|返回项在数组中的位置|<br>|lastIndexOf( )|同上|</p>
<p>接受两个参数：第一个是要查找的项，第二个参数表示的是表示起点位置的索引。</p>
<p>###5.2.8 迭代方法<br>|方法|功能|<br>|:—-|:—-|<br>|every( )|对数组的每一项运行给定函数，全部是true就会返回true|<br>|filter( )|对数组的每一项运行给点函数，返回改函数会返回<strong>true</strong>的项组成的数组|<br>|foeEach( )|对数组的每一项运行给点函数,无返回值|<br>|map( )|对数组的每一项运行给点函数,返回每次调用函数的结果组成的数组|<br>|some( )|对数组的每一项运行给点函数,如果该函数给任一项返回true，则就会返回true|</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//filter</span></span><br><span class="line">var numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line">var filterResult = numbers.filter(function(item)&#123;</span><br><span class="line">	<span class="keyword">return</span> (item &gt;<span class="number">2</span>);<span class="comment">//[3, 4, 5, 4, 3]</span></span><br><span class="line">&#125;);</span><br><span class="line">console.<span class="built_in">log</span>(filterResult);</span><br><span class="line"></span><br><span class="line"><span class="comment">//map</span></span><br><span class="line">var numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line">var mapResult = numbers.<span class="built_in">map</span>(function(item)&#123;</span><br><span class="line">	<span class="keyword">return</span> item*<span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line">console.<span class="built_in">log</span>(mapResult);<span class="comment">//[2, 4, 6, 8, 10, 8, 6, 4, 2]</span></span><br></pre></td></tr></table></figure>
<p>###5.2.9 缩小方法<br>|方法|功能|<br>|:—-|:—-|<br>|reduce( )|迭代数组的所有项，然后构建一个最终返回的值，从第一项开始|<br>|reduceRight( )|迭代数组的所有项，然后构建一个最终返回的值，从最后一项开始|</p>
<p>作为参数的函数接受4个参数：前一个值，当前值，项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var values =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">var sum = values.reduce(function(prev, cur, index, <span class="built_in">array</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> prev+cur;</span><br><span class="line">&#125;);</span><br><span class="line">console.<span class="built_in">log</span>(sum);<span class="comment">//15</span></span><br></pre></td></tr></table></figure></p>
<hr>
<p>##5.3 Date类型</p>
<p>#第六章 面向对象的程序设计<br>内容：</p>
<ul>
<li>理解对象属性</li>
<li>理解并创建对象</li>
<li>理解继承</li>
</ul>
<h2 id="6-1_理解对象">6.1 理解对象</h2><h3 id="6-1-1_属性类型">6.1.1 属性类型</h3><p>内部才有的特性，用[[…]]来表示的。<br>1.数据属性</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">[[Configurable]]</td>
<td style="text-align:left">能否delete删除属性从而重新定义、能否修改属性的特性、能否把属性修改为访问器属性。</td>
</tr>
<tr>
<td style="text-align:left">[[Enumerable]]</td>
<td style="text-align:left">能否通过for-in枚举。默认是true</td>
</tr>
<tr>
<td style="text-align:left">[[Eritable]]</td>
<td style="text-align:left">能否修改属性的值</td>
</tr>
<tr>
<td style="text-align:left">[[Value]]</td>
<td style="text-align:left">包含这个属性的数据值</td>
</tr>
</tbody>
</table>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="actionscript"></span><br><span class="line">	<span class="keyword">var</span> person = &#123;</span><br><span class="line">		name:<span class="string">"HuangZhuang"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如上所示：创建一个对象，它的默认内部属性前三个都是true,然后[[value]]被设置成了一个特定的值HuangZhuang。对象创建name属性，[[Value]]被设置了，在对name属性值得任何时候的修改都会反映在这个位置。</p>
<p>修改特性的默认值，只能调用：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.<span class="function"><span class="title">defineProperty</span><span class="params">(属性所在对象，<span class="string">"属性名字"</span>，<span class="string">"一个描述符对象"</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>如果要修改，则：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">	writable: <span class="literal">false</span>,</span><br><span class="line">	value: <span class="string">"hz"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//hz</span></span><br><span class="line">person.name= <span class="string">"hh"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//hz</span></span><br></pre></td></tr></table></figure></p>
<p>有一点注意：就是当Configurable是false时，其他三个的特性是要受到限制的，而且设定Object.defineProperty后，这四个特性均是默认设定成false的。</p>
<p>2.访问器属性<br>访问器属性不包含数组，但是包含一对getter和setter函数。</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">[[Configurable]]</td>
<td style="text-align:left">能否delete删除属性从而重新定义、能否修改属性的特性、能否把属性修改为访问器属性。</td>
</tr>
<tr>
<td style="text-align:left">[[Enumerable]]</td>
<td style="text-align:left">能否通过for-in枚举。默认是true</td>
</tr>
<tr>
<td style="text-align:left">[[Get]]</td>
<td style="text-align:left">读取属性时调用的函数</td>
</tr>
<tr>
<td style="text-align:left">[[Set]]</td>
<td style="text-align:left">写入属性时调用的函数</td>
</tr>
</tbody>
</table>
<p>访问器属性不可以直接定义，必须通过Object.defineProperty( )来定义。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">	_year : <span class="number">2004</span>,</span><br><span class="line">	edition: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line">Object.defineProperty(book, <span class="string">"year"</span>,&#123;</span><br><span class="line">	<span class="keyword">get</span>: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="keyword">set</span>: <span class="function"><span class="keyword">function</span><span class="params">(newValue)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(newValue &gt; <span class="number">2004</span>)&#123;</span><br><span class="line">			<span class="keyword">this</span>._year = newValue;</span><br><span class="line">			<span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line">alert(book.edition); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>下划线表示只能通过对象方法访问的属性。</p>
<h3 id="6-1-2_定义多个属性">6.1.2 定义多个属性</h3><p>Object.defineProperties(第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应)</p>
<h3 id="6-1-3_读取属性的特性">6.1.3 读取属性的特性</h3><p>一个函数Object.getOwnPropertyDescriptor( )针对属性是数据类型还是访问器类型返回出内部属性的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">"year"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>
<h2 id="6-2_创建对象">6.2 创建对象</h2><p>Object构造函数或对象字面量都可以创建单个对象，但是这种方式是有明显的缺点的：使用同一个接口创建很多对象，会产生大量的额重复代码。</p>
<h3 id="6-2-1_工厂模式">6.2.1 工厂模式</h3><p>用函数来封装以特定的接口创建对象的细节。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">	o.name = name;</span><br><span class="line">	o.age = age;</span><br><span class="line">	o.job = job;</span><br><span class="line">	o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o1 = createPerson(<span class="string">"hz"</span>, <span class="number">25</span>, <span class="string">'IT'</span>);</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>但是却没有解决对象识别的问题，即怎样知道一个对象的类型。</p>
<h3 id="6-2-2_构造函数模式">6.2.2 构造函数模式</h3><p>特点：</p>
<ul>
<li>没有显示的创建对象</li>
<li>直接将属性和方法赋值给this对象</li>
<li>没有return语句</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">this</span>.job = job;</span><br><span class="line">	<span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Person1 = <span class="keyword">new</span> Person(<span class="string">"hz"</span>, <span class="number">25</span>, <span class="string">"IT"</span>);</span><br></pre></td></tr></table></figure>
<p>构造函数始终都应该以一个大写字母开头，非构造函数才是用小写字母开头。</p>
<p>以上的例子中，要创建一个Person的新实例，要使用new操作符。经理四个步骤：</p>
<ul>
<li>1创建一个新对象。</li>
<li>2将构造函数打的作用域赋值给新对象，this就会指向新对象。</li>
<li>3执行构造函数中的代码。</li>
<li>4返回新对象。</li>
</ul>
<p>Person创建的实例，都有一个指向Person的Constructor属性。<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Person1.constructor == Person ); <span class="regexp">//</span><span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>构造函数与其他函数的唯一区别就是调用方式。new 操作符来调用函数就是构造函数，如果没有就和普通函数没有区别的。<br> <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为构造函数使用</span></span><br><span class="line"> <span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"hz"</span>, <span class="number">25</span>, <span class="string">"IT"</span>);</span><br><span class="line"> person.sayName();<span class="comment">//hz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//作为普通函数使用</span></span><br><span class="line">Person(<span class="string">"hz"</span>, <span class="number">25</span>, <span class="string">"IT"</span>);<span class="comment">//添加到window对象</span></span><br><span class="line"><span class="built_in">window</span>.sayName();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在另一个对象中使用</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">Person.call(o, <span class="string">"hz"</span>, <span class="number">25</span>, <span class="string">"IT"</span>); <span class="comment">//在o对象的特殊作用域中调用，o就拥有了所有属性和方法。</span></span><br><span class="line">o.sayName();</span><br></pre></td></tr></table></figure></p>
<p>构造函数的问题就是每个<strong>方法</strong>都要在每个实例上重新创建一遍。就是说不同实例上的同名函数实际上是不一样的。如果把这些方法通过全局作用域的函数调出来可以解决，但是当需要很多方法时，<em>封装性太差</em>。解决方法：原型模式。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var Person1 = <span class="keyword">new</span> Person(<span class="string">"hz"</span>, <span class="number">25</span>, <span class="string">"IT"</span>);</span><br><span class="line">var Person2 = <span class="keyword">new</span> Person(<span class="string">"hz"</span>, <span class="number">25</span>, <span class="string">"IT"</span>);</span><br><span class="line">console.<span class="built_in">log</span>(Person1.sayName == Person2.sayName); <span class="comment">//false</span></span><br></pre></td></tr></table></figure></p>
<p>1.理解原型对象<br>任何时候创建新函数，就会创建一个prototype属性，这个属性指向函数的原型对象。默认情况下，原型对象会自动获得一个constructor属性，这个属性包含一个<em>指向prototype属性所在函数的指针</em>。</p>
<p>虽然没有办法访问到[[prototype]],但是通过isPrototypeOf( )方法可以确定对象之间是否存在这种关系。如果[[prototype]]指向调用isPrototypeOf( )方法的对象，就会返回true。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(person1)); <span class="regexp">//</span><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>而ECMAScript5新增加的一个方法Object.getPrototypeOf( )返回的对象实际就是这个对象的原型。Object.getPrototypeOf( )很方便的取得一个对象的原型。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person1) == Person.prototype); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>几点说明：</p>
<ul>
<li>当代码读到属性时候，就会进行一次搜索，先从实例开始，如果没有搜到，则就会继续搜索指针指向的原型。</li>
<li>实例中重新定义新的属性和方法<em>不会改变原型中的属性和方法</em>，但是在调用该实例的时候会<em>屏蔽</em>原型的。</li>
<li>delete删除操作符可以完全删除实例属性。从而可以重新访问原型中的属性。</li>
<li>hasOwnPrototype( )检测一个属性是否存在实例中，还是存在原型中。这个方法是继承过来的，只有在实例设定属性或者方法的时候才会返回true；</li>
</ul>
<p>2.原型与in操作符</p>
<ul>
<li>单独使用in的时候，会在对象能够访问给定属性时返回true，实例和原型均可。<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person1); <span class="regexp">//</span><span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>通过hasOwnPrototype( )和in结合就可以封装一个检测属性是实例还是原型中的函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypeProperty</span>(<span class="params">object, name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !<span class="built_in">Object</span>.hasOwnProperty(name) &amp;&amp; (name <span class="keyword">in</span> object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>原理：只要in操作符返回true而且.hasOwnProperty( )返回false就可以判断属性是存在原型中的。</p>
<ul>
<li>for-in循环，返回的是所有能够通过对象访问的，可枚举的属性。包括在实例中的属性以及原型中的属性。屏蔽了原型中不可枚举属性的实例属性也会返回。<br>Object.keys()方法可以返回所有可枚举的实例属性。参数如果是xxx.prototype则返回原型课枚举的属性。如果对于实例调用则只会返回实例的属性和方法，不会返回原型的。<br>如果要得到所有属性和方法，不管是不是可枚举，则使用getOwnPrototypeNames()<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">keys</span> = Object.<span class="keyword">keys</span>(Person.<span class="keyword">prototype</span>);</span><br><span class="line">console.<span class="keyword">log</span>(<span class="keyword">keys</span>);<span class="regexp">//</span>[<span class="string">"name"</span>, <span class="string">"age"</span>, <span class="string">"job"</span>, <span class="string">"sayName"</span>];</span><br><span class="line">var key = Object.getOwnPropertyNames(Person.<span class="keyword">prototype</span>);</span><br><span class="line">console.<span class="keyword">log</span>(key);<span class="regexp">//</span>[<span class="string">"constructor"</span>, <span class="string">"name"</span>, <span class="string">"age"</span>, <span class="string">"job"</span>, <span class="string">"sayName"</span>];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>3.更简单的原型方法<br>为减少不必要的代码书写，可以使用如下的方法：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">        <span class="constructor"><span class="keyword">constructor</span> ： Person，//一般没有，是为了重新设置<span class="keyword">constructor</span>才用设置，但是会带来问题。</span><br><span class="line">	name : "hzhuang",</span><br><span class="line">	age : 25,</span><br><span class="line">	job : "IT",</span><br><span class="line">	sayName : function()</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上，Person.prototype设置成等于一个以对象字符量形式创建的新对象。但是值得注意的是此时constructor不再指向Person。此时的语法是完全重写了prototype对象，所以constructor属性就指向l构造函数Object，不再是Person了。如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">friend</span> = <span class="keyword">new</span> Person();</span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">friend</span>.constructor == Person);<span class="comment">//false</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">friend</span>.constructor == Object);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>如果想重新设定回去(让friend.constructor == Person是true)，那么就要在这个对象字面量里面添加一组condtructor的键值对。见3开始的例子。但是会带来问题，会让constructor属性变成可枚举的。</p>
<p>在兼容ECMAScript5的引擎中，可以用Object.definePeoperty来解决这个问题。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">Object</span><span class="class">.defineProperty</span>(Person.prototype, <span class="string">"constructor"</span>, &#123;</span><br><span class="line">	<span class="attribute">enumerable </span>: false,</span><br><span class="line">	<span class="attribute">value </span>: Person</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>4.原型的动态性<br>对原型对象所做的任何修改都可以立即在实例上反应出来。即使是先创建实例然后修改原型。<br>但是如果是重写原型，情况就大不一样了。调用构造函数时会为实例添加一个执行最初原型的[[prototype]]指针，而把原型修改成另一个对象就等于切断了构造函数与最初原型的联系。实例中的指针只执行原型，不指向构造函数。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="constructor"><span class="keyword">constructor</span> : Person,</span><br><span class="line">	name : "hzhuang",</span><br><span class="line">	age : 25,</span><br><span class="line">	job : "IT",</span><br><span class="line">	sayName : function()</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">friend.sayName();<span class="comment">//Uncaught TypeError: friend.sayName is not a function</span></span><br></pre></td></tr></table></figure></p>
<p>5.原生对象的原型<br>不建议修改原生对象的原型。</p>
<p>6.原型对象的问题</p>
<ul>
<li>省略了为构造函数传递初始化参数这一环节，结果所有实例在默认的情况下都将取得相同的属性值。</li>
<li>最大的问题是有共享的本性造成的。<br>原型中的所有属性都可以被很多实例共享，但是对于包含引用类型的属性来说们就会出现很明显的问题。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="constructor"><span class="keyword">constructor</span> : Person,</span><br><span class="line">	name : "hzhuang",</span><br><span class="line">	age : 25,</span><br><span class="line">	job : "IT",</span><br><span class="line">	friends : ["a", "b"],</span><br><span class="line">	sayName : function()</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.friends.push(<span class="string">"c"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person2.friends);<span class="comment">//["a", "b", "c"]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>问题好明显，我只是修改了实例1的friends，但是却在所有的实例中反应出来了。基于此，单独的原型模式一般是不常用的。</p>
<h3 id="6-2-4_组合使用构造函数模式和原型模式">6.2.4 组合使用构造函数模式和原型模式</h3><ul>
<li>构造函数用于定于实例属性；</li>
<li>原型模式用于定于方法和共享的属性。</li>
</ul>
<p>重写之前有问题的例子：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">this</span>.job = job;</span><br><span class="line">	<span class="keyword">this</span>.friends = [<span class="string">"a"</span>, <span class="string">"b"</span>];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="constructor"><span class="keyword">constructor</span> : Person,</span><br><span class="line">	sayName : function()</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见这种混合模式的优点：</p>
<ul>
<li>每个实例都有自己的实例属性的副本，同时又有共享的方法。</li>
<li>最大限度的节省了内存</li>
<li>还支持构造函数传递参数</li>
</ul>
<h3 id="6-2-5_动态原型模式">6.2.5 动态原型模式</h3><p>把所有的信息封装在构造函数中，而通过在构造函数中初始化原型，又保持了同时使用构造函数和原型的优点。就是说<strong>可以通过检测某个应该存在的方法是否有效，来决定是否需要初始化原型</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">this</span>.job = job;</span><br><span class="line">	<span class="keyword">this</span>.friends = [<span class="string">"a"</span>, <span class="string">"b"</span>];</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>)&#123;</span><br><span class="line">		Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"hzhuang"</span>, <span class="number">25</span>, <span class="string">"IT"</span>);</span><br><span class="line">friend.sayName();</span><br></pre></td></tr></table></figure></p>
<p>if( )部分只会在初次调用函数的时候执行，之后原型就完成初始化。此时原型的修改都会反映在实例中。</p>
<h3 id="6-2-6_寄生构造函数模式">6.2.6 寄生构造函数模式</h3><p>创建一个函数，这个函数的作用就是封装创建对象的代码，然后再返回新创建的对象。和工厂模式一样，区别只是这里是在一个函数里面并返回的这个对象。</p>
<h3 id="6-2-7_稳妥构造函数模式">6.2.7 稳妥构造函数模式</h3><ul>
<li>没有公共属性。</li>
<li>也不用this对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">	o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(name); <span class="comment">//不使用this</span></span><br><span class="line">	&#125;；</span><br><span class="line">	<span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了调用sayname( )方法外，没有其他方法可以访问到传入到构造函数中的原始数据，保证了一种安全性。</p>
<h2 id="6-3_继承">6.3 继承</h2><p>js没有接口继承，只支持实现继承。</p>
<h3 id="6-3-1_原型链">6.3.1 原型链</h3><p>原型链是实现继承的主要方法。<br>基本思路：利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>
<p>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而每个实例都包含一个指向原型函数对象的内部指针。<strong>如果将原型对象等于另一个类型的实例。则就会形成一个链</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承SuperType( )</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue());</span><br></pre></td></tr></table></figure>
<p>几点说明：</p>
<ul>
<li>instance.constructor指向SuperType，因为SubType的原型重写了。</li>
<li>instance指向SubType的原型</li>
<li>SubType的原型又指向SuperType的原型</li>
</ul>
<p>1.别忘记默认的原型<br>所有的函数的默认原型都是Object的实例，因此默认原型都会包含一个内部的指针，指向Object.prototype。这就是为什么函数可以继承toString( )等默认方法的根本原因。</p>
<p>2.确定原型和和实例的关系<br>两种方式：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方式</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">instanceof</td>
<td style="text-align:left">只要用这个操作符来测试实例与原型链中出现的构造函数，就会返回true。</td>
</tr>
<tr>
<td style="text-align:left">isPrototypeOf( )</td>
<td style="text-align:left">只要是原型链中出现过的原型，都可以说是该原生链所派生的实例的原型。</td>
</tr>
</tbody>
</table>
<p>3.谨慎的定义方法<br>给原型添加方法的代码一定要放在替换原型的语句之后。<br>必须在用要被继承的构造函数的实例替换当前的原型之后，再定义方法。<br>通过原型链实现继承的时候，不能使用对象字面量创建原型方法。因为这样会重写原型链。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承SuperType()</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line">SubType.prototype = &#123;</span><br><span class="line">	getSubValue : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">	&#125;,</span><br><span class="line">	someOhterMethod : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue()); <span class="comment">//error</span></span><br></pre></td></tr></table></figure></p>
<p>刚刚把SuperType的实例赋值给原型，接着又将原型替换成一个对象字面量而导致的问题。由于现在的原型包含的是一个Object的实例，而非SuperType的实例，因此我们设想的原型链已经被切断了。</p>
<p>4.原型链的问题<br>最大的问题是引用类型值的原型。还是共享问题。引用类型。<br>基于此，很少单独使用原型链。</p>
<h3 id="6-3-2_借用构造函数">6.3.2 借用构造函数</h3><p>解决单独原型链中引用类型带来的问题，借用构造函数的技术。<br>基本思想：在子类型构造函数的内部调用超类型构造函数。函数是特定环境中执行代码的对象，可以使用apply( )和call( )方法在新创建的对象上执行构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">//继承SuperType</span></span><br><span class="line">	SuperType.call(<span class="keyword">this</span>, <span class="string">"hzhaung"</span>);<span class="comment">//hzhuang是传递的参数。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">"blcak"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//["red", "blue", "green", "blcak"]</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);<span class="comment">//["red", "blue", "green"]</span></span><br></pre></td></tr></table></figure>
<p>在新SubType对象上执行SuperType( )函数中定义的所有对象初始化代码。<br>1.传递参数<br>2.借用构造函数的问题<br>方法在构造函数中定义，所以就无法复用。</p>
<h3 id="6-3-3_组合继承">6.3.3 组合继承</h3><p>将原型链和借用构造函数的技术组合在一起。<br>思路：使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样在原型上定义的方法实现了函数的复用，又可以保证每个实例有它自己的属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//继承SuperType</span></span><br><span class="line">	SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"hzhuang"</span>, <span class="number">25</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"blcak"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//["red", "blue", "green", "blcak"]</span></span><br><span class="line">instance1.sayName();<span class="comment">//hzhuang</span></span><br><span class="line">instance1.sayAge();<span class="comment">//25</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"hz"</span>, <span class="number">26</span>);</span><br><span class="line">instance2.sayName();<span class="comment">//hz</span></span><br><span class="line">instance2.sayAge();<span class="comment">//26</span></span><br></pre></td></tr></table></figure></p>
<h3 id="6-3-4_原型式继承">6.3.4 原型式继承</h3><p>没有严格意义上的构造函数。借助原型可以基于已有的对象创建新对象，同时还不比创建自定义类型。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span><span class="params">(o)</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span></span>&#123;</span><br><span class="line">		F.prototype = o;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在object函数内部，先创建了yige 临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回这个临时类的一个新实例。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">		F.prototype = o;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	name : <span class="string">"hzhuang"</span>,</span><br><span class="line">	friends : [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = object(person);</span><br><span class="line">anotherPerson.name = <span class="string">"hz"</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yetanotherPerson = object(person);</span><br><span class="line">yetanotherPerson.name = <span class="string">"hh"</span>;</span><br><span class="line">yetanotherPerson.friends.push(<span class="string">"e"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.friends);<span class="comment">//["a", "b", "c", "d", "e"]</span></span><br></pre></td></tr></table></figure></p>
<p>在上面的实例中，可以用Object.create( )来代替自定义的object函数。但是可以达到相同的效果。</p>
<h3 id="6-3-5_寄生式继承">6.3.5 寄生式继承</h3><p>思路与寄生构造函数和工厂模式类似，即创建一个仅仅用于<strong>封装继承过程的函数</strong>，改函数内部已某种方式增强对象。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span><span class="params">(o)</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">		F.prototype = o;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	name : <span class="string">"hzhuang"</span>,</span><br><span class="line">	friends : [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span><span class="params">(original)</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> <span class="keyword">clone</span> = object(original);</span><br><span class="line">	<span class="keyword">clone</span>.sayHi = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> console.log(<span class="string">"hi"</span>);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">clone</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi();</span><br></pre></td></tr></table></figure></p>
<h3 id="6-3-6_寄生组合式继承">6.3.6  寄生组合式继承</h3><p>基本思路：不必为了指定子类型的原型而调用超类型的构造函数，所需要的无非是超类型原型的一个副本人而已。本质上使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span><span class="params">(subType, superType)</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> prototype = object(superType.prototype);<span class="comment">//创建对象，创建超类型原型的一个副本。</span></span><br><span class="line">	prototype.constructor = subType;<span class="comment">//增强对象</span></span><br><span class="line">	subType.prototype = prototype;<span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="第七章_函数表达式">第七章 函数表达式</h1><ul>
<li>函数表达式的特征</li>
<li>使用函数实现递归</li>
<li>使用闭包定义私有变量</li>
</ul>
<p>函数声明可以先调用，然后再声明，不会跑出错误。但是如果你使用函数表达式的方法，则必须先创建函数啊，然后调用。</p>
<p>函数表达式：var huang=function（a，b）{}；这种情况叫做匿名函数，因为function后面没有标识符。在使用前必须先赋值。</p>
<h2 id="7-1_递归">7.1 递归</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">factorial</span><span class="params">(num)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(num &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> num*arguments.callee(num-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>arguments.callee是一个指向正在执行函数的指针。</p>
<h2 id="7-2_闭包">7.2 闭包</h2><p>闭包：有权访问另一个函数作用域中的变量的函数。最常见的方式就是在一个函数内部创建另一个函数。</p>
<p>函数被调用的时候，会创建一个执行环境和相应的作用域链，然后用arguments或者其他命名参数来初始化函数的活动对象。</p>
<ul>
<li>每一个执行环境都有有一个变量对象。全局变量对象始终存在，而局部的活动对象（本地活动对象）只在函数执行的过程中存在。</li>
<li>作用域链的本质是一个指向变量对象的指针列表，它只是引用。</li>
</ul>
<p>在另一个函数内部定义的函数会将包含函数（外部函数）的活动对象添加到它的作用域中。<br>函数调用完成后不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。</p>
<p>###7.2.1 闭包和变量<br>闭包中保存的是整个变量对象，所以闭包只能取得包含函数中任何变量的最后一个值。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function createFunctions()&#123;</span><br><span class="line">	<span class="keyword">var</span> <span class="literal">result</span> = new <span class="type">Array</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">		<span class="literal">result</span>[i] = function()&#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> funcs = createFunctions();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">	document.write(funcs[i]() + <span class="string">"&lt;br /&gt;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出的全是10，值得注意的是：funcs[i]输出的是一个函数，则在后面加上()就会执行返回i的值。<br>想到达预期的效果，则如下：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function createFunctions()&#123;</span><br><span class="line">	<span class="keyword">var</span> <span class="literal">result</span> = new <span class="type">Array</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">		<span class="literal">result</span>[i] = function(num)&#123;</span><br><span class="line">			<span class="keyword">return</span> function()&#123;</span><br><span class="line">				<span class="keyword">return</span> num;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###7.2.2 关于this对象<br>匿名函数的执行环境具有全局性，因此一般this指向window。但是有时候由于闭包的方式不同，这一点可能不同。<br>闭包中，内部函数是在先搜索自己内部的活动对象那个，如果找不到的话就会继续搜索外部包含它的函数。<br>如果将外部函数作用域中的this对象保存在一个闭包能够访问的变量里。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> that.xxx; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###7.2.3 内存泄露<br>内存泄露：闭包会引用包含函数的整个活动对象。<br>这种方式可以有效的回收内存。</p>
<p>##7.3 模仿块级作用域<br>js没有块级作用域的概念，所以对于for里面的声明的变量在函数内部也是可以读取的。对后续的声明无视，但是初始化值会执行。匿名函数模仿块级作用域（私有作用域）。<br>区别：<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">function</span><span class="list">(<span class="keyword">args</span>)</span><span class="collection">&#123; //这是一个函数表达式，后面加上<span class="list">()</span>表示立即调用。</span><br><span class="line">	xxx; //块级作用域。</span><br><span class="line">&#125;</span>)</span><span class="list">()</span></span><br></pre></td></tr></table></figure></p>
<p>如果没有保住function的括号，则就是函数声明，函数声明后面是不能加括号的。</p>
<p>##7.4 私有作用域<br>没有私有成员的概念，但是有私有变量的概念。（函数中定义的都是私有变量）<br>访问私有变量的公有方法：就是在函数内部调用一个特殊的方法，利用闭包的作用链来访问这些私有变量和私有方法。构造函数实现，对每个实例都重新创建。</p>
<p>###7.4.1 静态私有变量<br>在私有作用域中定义私有变量和函数，也可以创建特权方法。<br>在匿名函数里面，通过不声明函数的方法使这个方法成为全局的，所有就可以在私有作用域之外也可以访问到私有变量和方法。<br>区别：私有变量和方法是实例共享的。实例的参数变化会影响所有的实例。</p>
<p>###7.4.2 模块模式<br>在定义私有变量和函数后，return一个对象字面量。这个对象字面量包含可以公开的属性和方法。</p>
<h1 id="第八章_BOM">第八章 BOM</h1><p>主要内容</p>
<ul>
<li>理解window对象</li>
<li>控制窗口、框架和弹出窗口</li>
<li>location对象中的页面信息</li>
<li>navigator对象了解浏览器</li>
</ul>
<h2 id="8-1_window对象">8.1 window对象</h2><p>BOM的核心对象是window，它表示浏览器的一个实例。</p>
<ul>
<li>window对象既是js访问浏览器窗口的一个接口。</li>
<li>window也是ECMAScript规定的Global对象。网页中定义的对象、函数等都以window作为Global对象。</li>
</ul>
<h3 id="8-1-1_全局作用域">8.1.1 全局作用域</h3><p>由于window的特性，所以在在全局作用域中声明的变量、函数都会变成window对象的属性和方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">29</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayAge</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.age);</span><br><span class="line">sayAge();</span><br><span class="line"><span class="built_in">window</span>.sayAge();</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>定义全局变量与在window对象上定义属性还有一点差别：全局变量不能通过delete操作符删除，但是在window对象上定义的属性可以使用这个操作符。</p>
</blockquote>
<h3 id="8-1-2_窗口关系及框架">8.1.2 窗口关系及框架</h3><p>页面中如果有框架，则每个框架都有自己的window对象。保存在frames集合中。每个window都有各自的name属性。<br>不常用，忽略。</p>
<h3 id="8-1-3_窗口位置">8.1.3 窗口位置</h3><p>screenLeft和screenTop属性，分别用于表示窗口相对于屏幕左边和上面的位置。特别的是：在FireFox中，是screenX和screenY两个属性来完成相同的功能。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> leftPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenLeft == <span class="string">"number"</span>)?<span class="built_in">window</span>.screenLeft : <span class="built_in">window</span>.screenX;</span><br><span class="line"><span class="keyword">var</span> topPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenTop == <span class="string">"number"</span>)?<span class="built_in">window</span>.screenTop : <span class="built_in">window</span>.screenY;</span><br></pre></td></tr></table></figure></p>
<p>关于方法moveTo( )和moveBy( )浏览器一般是禁用的。</p>
<h3 id="8-1-4_窗口大小">8.1.4 窗口大小</h3><p>关于窗口大小属性的四个：outerWidth/innerWidth/outerHeight/innerOuter在各浏览器中的渲染差别。</p>
<ul>
<li>IE9+、Safari和FireFox：outerWidth/outerHeight返回浏览器窗口本身的尺寸。</li>
<li>Opera： outerWidth/outerHeight表示页面视图容器的大小。</li>
<li>Chrome：innerWidth/innerHeight一般表示页面中视图区的大小（减去边框宽度）。而chrome中这对属性的值和outerWidth/outerHeight返回的值大小是一样的，都表示视口的大小。</li>
</ul>
<p>跨浏览器确定浏览器的窗口无法实现，但是可以获取到页面视口的大小。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pageWidth = <span class="built_in">window</span>.innerWidth;</span><br><span class="line"><span class="keyword">var</span> pageHeight = <span class="built_in">window</span>.innerHeight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> pageWidth != <span class="string">"number"</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">document</span>.compatMode == <span class="string">"CSS!compatMode"</span>)&#123; <span class="comment">//检查是否处于标准模式</span></span><br><span class="line">		pageWidth =<span class="built_in">document</span>.documentElement.clientWidth;</span><br><span class="line">		pageHeight = <span class="built_in">document</span>.documentElement.clientHeight;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		pageWidth = <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line">		pageHeight = <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>移动设备中，IE的浏览器的视口大小的值是可见视口的值，而其他浏览器的值就是布局视口的值。</p>
<p>同样有resizeTo( )和resizeBy( )，但是一般浏览器禁止。</p>
<h3 id="8-1-5_导航和打开窗口">8.1.5 导航和打开窗口</h3><p>window.open( )可以打开导航到一个特定的URL，也可以打开一个新的浏览器窗口。<br>window.open( )接受四个参数：要加载的URL、窗口目标、一个特性字符串以及新页面是否取代浏览器历史记录中当前加载页面的布尔值。</p>
<ul>
<li>第一个参数：要加载的URL</li>
<li>第二个参数：窗口目标。<ul>
<li>已存在的窗口或者框架属性。</li>
<li>特殊的窗口名称：_self、_parent、_top或_blank。</li>
</ul>
</li>
<li>第三个参数：在第二个参数并不是一个存在的窗口或者框架的时候。则会根据第三个设置的特性值新建窗口或者框架。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">特性值</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">fullscreen,取值yes或no</td>
<td style="text-align:left">仅限IE</td>
</tr>
<tr>
<td style="text-align:left">height</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">left</td>
<td style="text-align:left">新窗口的左坐标</td>
</tr>
<tr>
<td style="text-align:left">location取值yes或no</td>
<td style="text-align:left">是否在新窗口中显示地址栏</td>
</tr>
<tr>
<td style="text-align:left">menubar取值yes或no</td>
<td style="text-align:left">是否在新窗口中显示菜单栏</td>
</tr>
<tr>
<td style="text-align:left">resizeable</td>
<td style="text-align:left">是否可以通过拖动浏览器窗口的边框改变其大小</td>
</tr>
<tr>
<td style="text-align:left">scrollbars</td>
<td style="text-align:left">是否允许有滚动</td>
</tr>
<tr>
<td style="text-align:left">status</td>
<td style="text-align:left">是否在新窗口中显示状态栏</td>
</tr>
<tr>
<td style="text-align:left">toolbar</td>
<td style="text-align:left">是否在新窗口中显示工具栏</td>
</tr>
<tr>
<td style="text-align:left">top</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">width</td>
<td style="text-align:left">无</td>
</tr>
</tbody>
</table>
<p>以上的设置值是yes或者no的默认值都是no。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> hzhuang</span> = window.<span class="keyword">open</span>(<span class="string">"http://localhost:4000/"</span>, <span class="string">"hzhaung"</span>, <span class="string">"height=400,width:400,resizeable=no"</span>);</span><br></pre></td></tr></table></figure></p>
<p>window.close( )方法用于关闭新打开的窗口。浏览器主窗口是不可以使用这个方法的，凡是弹出的窗口却可以。</p>
<p>新创建的window对象有一个<strong>opera属性</strong>，保存着打开它的原始窗口对象。</p>
<p>可以通过设置这些特性字符串来处理网页上肆无忌惮的广告问题。</p>
<p><strong>弹出窗口屏蔽程序</strong><br>大多数浏览器都内置屏蔽弹出窗口。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> blocked</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="variable"><span class="keyword">var</span> wroxWin</span> = window.<span class="keyword">open</span>(<span class="string">"http://www.wrox.com"</span>, <span class="string">"_blank"</span>);</span><br><span class="line">    <span class="keyword">if</span> (wroxWin == <span class="literal">null</span>)&#123;</span><br><span class="line">        blocked = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ex)&#123;</span><br><span class="line">    blocked = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (blocked)&#123;</span><br><span class="line">    alert(<span class="string">"The popup was blocked!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="8-1-6_间歇调用和超时调用">8.1.6 间歇调用和超时调用</h3><p>windo对象的setTimeout( )方法。<br>这个方法会返回一个数值ID，表示超时调用。用clearTimeout(set方法返回的值)来取消。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timeoutID = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"hzhuang"</span>);&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(timeoutID);<span class="comment">//1</span></span><br></pre></td></tr></table></figure></p>
<p>window对象的setInterval( )实现间歇调用。</p>
<h3 id="8-1-7_系统对话框">8.1.7 系统对话框</h3><p>三种：alert() + confirm( ) + prompt( )</p>
<ul>
<li>与显示的网页没有关系。</li>
<li>外观由操作系统决定，并非css。</li>
<li>显示的时候代码是停止执行的。</li>
</ul>
<h2 id="8-2_location对象">8.2 location对象</h2><p>​location对象即是window对象的属性，也是document对象的属性。</p>
<ul>
<li>保存当前文档的信息</li>
<li>将URL解析成独立的片段</li>
</ul>
<p>以“<a href="http://www.wrox.com:80#contents”为例" target="_blank" rel="external">http://www.wrox.com:80#contents”为例</a></p>
<table>
<thead>
<tr>
<th style="text-align:left">属性名</th>
<th style="text-align:left">例子</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">hash</td>
<td style="text-align:left">“#contents”</td>
<td style="text-align:left">URL的hash，就是#号后面的字符串</td>
</tr>
<tr>
<td style="text-align:left">host</td>
<td style="text-align:left">“www.wrox.com”80”</td>
<td style="text-align:left">返回服务器名称和端口号</td>
</tr>
<tr>
<td style="text-align:left">hostname</td>
<td style="text-align:left">…</td>
<td style="text-align:left">返回服务器名</td>
</tr>
<tr>
<td style="text-align:left">href</td>
<td style="text-align:left">“<a href="http://www.wrox.com”" target="_blank" rel="external">http://www.wrox.com”</a></td>
<td style="text-align:left">返回当前加载页面的完整URL</td>
</tr>
<tr>
<td style="text-align:left">pathname</td>
<td style="text-align:left">/…/</td>
<td style="text-align:left">url的路径名</td>
</tr>
<tr>
<td style="text-align:left">port</td>
<td style="text-align:left">“80”</td>
<td style="text-align:left">端口</td>
</tr>
<tr>
<td style="text-align:left">protocal</td>
<td style="text-align:left">“http”</td>
<td style="text-align:left">协议</td>
</tr>
<tr>
<td style="text-align:left">search</td>
<td style="text-align:left">”？q=javascript“</td>
<td style="text-align:left">返回URL中的查询字符串，以问号开头</td>
</tr>
</tbody>
</table>
<h3 id="8-2-1_查询字符串参数">8.2.1 查询字符串参数</h3><p>解决location.search只能返回问号后面全部字符串而不精确的问题。<br>构造一个函数，解析查询字符串，然后返回包含所有参数的一个<em>对象</em>。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">getQueryStringArgs</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> qs = (location.search.length &gt; <span class="number">0</span> ? location.search.substring(<span class="number">1</span>) : <span class="string">""</span>),</span><br><span class="line">	args = &#123;&#125;,<span class="comment">//保存数据的对象</span></span><br><span class="line">	<span class="comment">//获取每一项</span></span><br><span class="line">	items = qs.length ? qs.split(<span class="string">"&amp;"</span>) : [],</span><br><span class="line">	item = <span class="keyword">null</span>,</span><br><span class="line">	name = <span class="keyword">null</span>,</span><br><span class="line">	<span class="keyword">value</span> = <span class="keyword">null</span>,</span><br><span class="line">	i = <span class="number">0</span>,</span><br><span class="line">	len = items.length;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;len ;i++)&#123;</span><br><span class="line">		item = items[i].split(<span class="string">"="</span>);</span><br><span class="line">		name = decodeURLComponent(item[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">value</span> = decodeURLComponent(item[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">if</span>(name.length)&#123;</span><br><span class="line">			args[name]= <span class="keyword">value</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###8.2.2 位置操作<br>location对象可以用很多方式改变浏览器的位置。常用的是<strong>assign( )</strong>。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.<span class="function"><span class="title">assign</span><span class="params">(<span class="string">"http://huangzhuang.github.io/"</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>以上代码可以立即打开我的博客，并在浏览器中的历史记录中生成一条记录。</p>
<blockquote>
<p>window.location和location.href设置成URL时，也会调用assign的方法，达到相同的效果。</p>
</blockquote>
<p>同时设置location对象的其他属性也可以改变URL。</p>
<p>为了禁止在浏览器器中生成历史记录，可以采用<strong>replace( )</strong>的方法。</p>
<p>最后一个方法是reload( )，重新加载当前页面。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.<span class="function"><span class="title">reload</span><span class="params">(true)</span></span> <span class="comment">//带true表示的是从服务器中重新加载的。</span></span><br></pre></td></tr></table></figure></p>
<h2 id="8-3_navigator对象">8.3 navigator对象</h2><p>关于属性，不常用，详见P210.</p>
<h3 id="8-3-1_检测插件">8.3.1 检测插件</h3><p>对于非IE浏览器而言，使用plugins数组来实现插件检测。</p>
<p>plugins数组有以下的属性：</p>
<ul>
<li>name 插件的名字。</li>
<li>description插件的描述。</li>
<li>filename插件的文件名。</li>
<li>length插件所处理的MIME类型数量。</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测是否有xx插件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPlugin</span><span class="params">(name)</span></span>&#123;</span><br><span class="line">	name = name.toLowwerCase();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;navigator.plugins.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(navigator.plugins[i].name.toLowwerCase().indexOf(name) &gt; -<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要再IE浏览器中检查插件，则使用唯一的专有的ActiveXObjext类型。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//plugin detection for IE</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasIEPlugin</span><span class="params">(name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> ActiveXObject(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ex)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###8.3.2 注册处理程序</p>
<p>##8.4 screen对象<br>screen对象基本上只用来表明客户端的能力。<br>属性详见P214</p>
<h2 id="8-5history对象">8.5history对象</h2><p>history是window对象的属性。借由用户访问过的页面列表，可以实现在不知道实际URL的情况下实现后退和前进。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">history</span>.<span class="keyword">go</span>(num/url);</span><br><span class="line"><span class="keyword">history</span>.back();</span><br><span class="line"><span class="keyword">history</span>,forward();</span><br></pre></td></tr></table></figure></p>
<p>#第十章 DOM</p>
<ul>
<li>理解包含不同层次节点的DOM</li>
<li>使用不同的节点类型</li>
<li>克服浏览器兼容性问题以及各种陷阱</li>
</ul>
<h2 id="10-1_节点层次">10.1 节点层次</h2><p>所有页面标记则表现为一个以特定节点为根节点的树形结构。</p>
<h3 id="10-1-1_Node类型">10.1.1 Node类型</h3><p>每个节点有nodeType属性。<br> 为了兼容所有浏览器，最好是将nodeType的值与1-12之间的数值比较。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（somenode.nodeType = =<span class="number">1</span>）&#123;alert(<span class="string">"该节点是一个元素节点"</span>)&#125;</span><br></pre></td></tr></table></figure></p>
<p>####1.nodeName和nodeValue属性<br>nodeName和nodeValue属性是节点的具体信息，使用前检测下节点的类型。<br>元素节点的nodeName是标签名，而它的nodeValues是null。</p>
<p>####2. 节点关系<br>每个节点都有一个<strong>childNodes属性</strong>，保存着nodeList对象（一个类数组，用于保存一组有序的节点）。<br>nodeList对象有length属性，且并不是Array的实例，而是会随时变化的，随DOM的结构变化自动变化。<br>通过方括号或者item()方访问nodeList中的节点。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> firstChild</span> = someNode.childNodes[<span class="number">0</span>];</span><br><span class="line"><span class="variable"><span class="keyword">var</span> secondChild</span> = someNode.childNodes.item[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//将nodeLists转化成数组。</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> arrayOfNodes</span> = Array.prototype.slice.call(someNode.childNodes, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>关于Array.prototype.slice.call()可以将arguments对象转成数组，<a href="http://www.cnblogs.com/littledu/archive/2012/05/19/2508672.html" target="_blank" rel="external">参考解释</a>。<br>大致是先调用toArray()方法，然后再执行slice()方法。</p>
<p>关于将nodeList对象转换成数组，兼容IE8及以下的方法是：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function<span class="function"> convertToArray(</span>nodes<span class="function">)</span>&#123;</span><br><span class="line">	var<span class="instruction"> array </span>= <span class="keyword">[</span>];</span><br><span class="line">	try&#123;</span><br><span class="line">		//针对非IE8及以下浏览器</span><br><span class="line">	<span class="instruction">	array </span>=<span class="function"> Array.prototype.slice.call(</span>nodes, 0<span class="function">)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	catch(ex<span class="function">)</span>&#123;</span><br><span class="line">	<span class="instruction">	array </span>=<span class="instruction"> new </span>Array(<span class="function">)</span>;</span><br><span class="line">		for(var i=0, len= nodes.length; i&lt; len; i++<span class="function">)</span>&#123;</span><br><span class="line">			array<span class="keyword">[</span>i].push(nodes<span class="keyword">[</span>i]<span class="function">)</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="instruction">	return </span>array; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每个节点有一个<strong>parentNode属性</strong>，指向文档树中的父节点。<br>比如someNode.childNodes中的每个节点都有同样的父节点someNode。而且他们之间是同胞节点（previousSibling 和 nextSbling）。</p>
<p>firestChild和lastChild属性的意义就很明显了。<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">someNode.firstChild == someNode.childNodes<span class="string">[0]</span>;</span><br><span class="line">someNode,lastCHild == someNode.childNodes<span class="string">[someNode.childNodes.length - 1]</span>;</span><br></pre></td></tr></table></figure></p>
<p>hasChildNodes()方法：节点包含一个或者多个子节点的情况下返回true</p>
<p>每个节点还有一个<strong>ownerDocument属性</strong>，指向文档的文档节点。不可以跨几个。</p>
<p>####3.操作节点<br>|方法|描述|<br>|:—|:—|<br>|appendChild( )|用于向childNodes列表的末尾添加一个节点。这个方法会<strong>返回新增的节点</strong>。|<br>|insertBefore()|(插入的节点，作为参考的节点 )|<br>|replaceChild()|（插入的节点，要替换的节点）|<br>|removeChild|（移除的节点）|<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> huang</span>= someNode.appendChild(newNode);</span><br><span class="line">alert (huang == newNode); <span class="comment">//返回true;</span></span><br></pre></td></tr></table></figure></p>
<p>如果要传入的节点已经是DOM的一部分，则结果就是将该节点从原来的位置转移到新的位置。（实现转移！）</p>
<blockquote>
<p>四种操作方法都是摸个节点的子节点，如果是不支持子节点的节点就会报错的。比如文本节点没有子节点。</p>
</blockquote>
<p>两个所有节点都有的方法：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">cloneNode(true)</td>
<td style="text-align:left">true表示深复制，就是复制节点及其子节点树。复制后孤立。不会复制js属性。</td>
</tr>
<tr>
<td style="text-align:left">normalize()</td>
<td style="text-align:left">删除后代中的空文本节点，然后把相邻的文本节点合并。</td>
</tr>
</tbody>
</table>
<p>###10.1.2 Document类型(9)<br>nodeType == 9<br>document对象是HTMLDocument的一个实例，表示整个HTML页面。且是window对象的一个属性。</p>
<p>####1.文档的子节点<br>内置两个访问子节点的快捷方式,所有的浏览器均支持这两个。</p>
<ul>
<li>documentElement指向html标签，这个更加方便快捷。</li>
<li>通过childNodes列表访问。</li>
</ul>
<p>一下三个是等价的。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> html</span> =document.documentElement;</span><br><span class="line"><span class="variable"><span class="keyword">var</span> html1</span> = document.childNodes[<span class="number">0</span>];</span><br><span class="line"><span class="variable"><span class="keyword">var</span> html2</span> = doxument.firstChild;</span><br></pre></td></tr></table></figure></p>
<p>document对象有body属性<br><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">body</span> = document.<span class="keyword">body</span>;</span><br></pre></td></tr></table></figure></p>
<p>documen对象有doctype属性,各浏览器支持差异，使用不多。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dovtype = <span class="built_in">document</span>.doctype;</span><br></pre></td></tr></table></figure></p>
<p>对于出现在html之外的注释，各个浏览器解析也存在差异。也就是document的childNodes不同。</p>
<ul>
<li>IE8及以前，safari3.1及以后。为第一个注释创建节点。其他的就忽略。</li>
<li>IE9及以上，就是正常的情况，所有的注释都是创建了节点。</li>
<li>Firefox和safari以前，完全忽略注释的存在。</li>
</ul>
<p>####2.文档信息<br>作为HTMLDocument的实例，有一些特别的属性。</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">title</td>
<td style="text-align:left">document.title</td>
</tr>
<tr>
<td style="text-align:left">URL</td>
<td style="text-align:left">包含页面完整的URL</td>
</tr>
<tr>
<td style="text-align:left">domain</td>
<td style="text-align:left">只包含域名</td>
</tr>
<tr>
<td style="text-align:left">referrer</td>
<td style="text-align:left">保存着链接到当前页面的那个页面的URL</td>
</tr>
</tbody>
</table>
<p>后面的三个属性是与网页的请求有关，存在请求的http头部。且只有domian是可以设置的，但是不可以任意设置。而且可以把子域设置成域而不能把域设置成子域（不能loose到tight）。</p>
<p>理解是这样的：<br>由于跨域，不同的子域的页面是无法通过js通信。可是将两个子域的domian设置为相同的值就可以通信了。</p>
<p>####3.查找元素，document对象的几个方法。</p>
<ul>
<li>document.getElementById():很常见，但是要注意一点就是在IE8及以下中会返回name值等于这个id名的表单元素。</li>
<li><p>document.getElementsByTagName：返回一个HTMLCollection对象，这个对象与nodeList对象类似，也可以使用方括号或者item()来读取。<br>这个HTMLCollection对象还有一个namedItem方法，来获取这个集合中name特性的项。则可以知道：HTMLCollection而言，可以传入数值或者字符串，前者后台会调用item(),后者则调用namedItem()。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> img</span> = doceument.getElemmentdbyTagName(<span class="string">"img"</span>);</span><br><span class="line"><span class="variable"><span class="keyword">var</span> myImg</span> = img.namedItem(<span class="string">"hzhuang"</span>);<span class="comment">//可以获取到name是hzhuang的那张图片。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>document.getElementByName()。</p>
</li>
</ul>
<p>####4.特殊集合<br>这些特殊的集合都是HTMLCollection对象。</p>
<table>
<thead>
<tr>
<th style="text-align:left">集合</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">document.anchors</td>
<td style="text-align:left">包含文档中所有带name特性的a标签</td>
</tr>
<tr>
<td style="text-align:left">document.forms</td>
<td style="text-align:left">包含文档中所有的form元素</td>
</tr>
<tr>
<td style="text-align:left">document.images</td>
<td style="text-align:left">包含文档中所有img标签</td>
</tr>
<tr>
<td style="text-align:left">document.links</td>
<td style="text-align:left">包含文档中所有带href属性的a元素</td>
</tr>
</tbody>
</table>
<p>#####5.DOM一致性检测<br>检测浏览器实现了DOM的哪些部分。<br><strong>document.implementation</strong>属性就是来实现这个功能的。<br>它有一个方法hasFeature().如果浏览器支持给定名称和版本的功能就会返回true。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasXmlDom = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">"XML"</span>, <span class="string">"1.0"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(hasXmlDom); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>####6.文档写入<br>将输出流写出到网页中。</p>
<ul>
<li>write:参数里面包含script标签时闭合的/要转义。</li>
<li>writeIn会自动在后面加上（/n）。</li>
</ul>
<p>###10.1.3 Element类型(1)<br>nodeType == 1<br>访问元素的标签名：</p>
<ul>
<li>nodeName属性</li>
<li>tagName属性</li>
</ul>
<p>在HTML返回的都是大写的。所以采用以下的方式进行比较返回的是否是哪个。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if<span class="list">(<span class="keyword">element</span>.nodeName.toLowerCase<span class="list">()</span> == <span class="string">"div"</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>####1.html元素<br>每个html元素都有以下的特性：</p>
<ul>
<li>id</li>
<li>title</li>
<li>dir：修改就会立即反映在页面中。</li>
<li>lang</li>
<li>className：改变值可以直接关联新的样式。</li>
</ul>
<p>####2.取得特性<br>操作特性的方法：<br>getAttribute() + setAttribute() + removeAttrvbute() </p>
<p>两类特殊的特性：</p>
<ul>
<li>style：getAttribute()返回的是style里面的文本。而通过属性来访问则是一个对象。</li>
<li>onclick：getAttribute()返回相应代码的字符串。而访问onclick属性时候返回的是一个js函数。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"huang"</span> <span class="attribute">onclick</span>=<span class="value">"huang()"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line">	<span class="keyword">var</span> str = <span class="built_in">document</span>.getElementById(<span class="string">"huang"</span>);</span><br><span class="line">	<span class="keyword">var</span> huang = str.getAttribute(<span class="string">"onclick"</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(str.onclick); <span class="comment">//function onclick</span></span><br><span class="line">	<span class="built_in">console</span>.log(huang); <span class="comment">//huang()</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">huang</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"123"</span>);</span><br><span class="line">	&#125;</span></span><br></pre></td></tr></table></figure>
<p>所以一般不适用getAttribute()这个方法，而是在访问自定义属性的时候用到。</p>
<p>####3.设置属性<br>setAttribute()<br>IE7及以下对于class和style的设置没有效果。<br>IE6不支持removeAttribute()</p>
<p>####4.attributes属性<br>atributes属性中包含一个NamedNodeMap，与nodeList类似。<br>有以下的方法：</p>
<ul>
<li>getNamedItem(name):返回nodeName等于name的节点。</li>
<li>removeNamedItem(name);</li>
<li>setNamedItem(name);</li>
<li>item(pos):返回位于数字跑pos位置处的节点。</li>
</ul>
<p>attributes属性包含一系列节点，每个节点的nodeName就是特性的名称。每个节点的nodeValue就是特性的值。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> id</span> = element.attributes.getNamedItem(<span class="string">"id"</span>).nodeValue;</span><br><span class="line">id = <span class="string">"huang"</span>;<span class="comment">//将id设置成新值。</span></span><br></pre></td></tr></table></figure>
<p>attributes属性一般用的不多，但是在<strong>遍历元素的特性</strong>的时候是很有用的。然后以name = value的形式输出。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id = <span class="string">"hzhuang"</span> name = <span class="string">"hzhuang"</span> dir = <span class="string">"ltr"</span> class = <span class="string">"hzhuang"</span> title=<span class="string">"hzhuang"</span>&gt;&lt;/div&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputAttribute</span><span class="params">(element)</span></span>&#123;</span><br><span class="line">	element = element.attributes;</span><br><span class="line">	var <span class="built_in">pairs</span> = [], attrName, attrValue, i , len=element.length;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; len; i++)&#123;</span><br><span class="line">		attrName = element[i].nodeName;</span><br><span class="line">		attrValue = element[i].nodeValue;</span><br><span class="line">		<span class="built_in">pairs</span>.push(attrName + <span class="string">"=\'"</span> + attrValue + <span class="string">"\'"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">pairs</span>.join(<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">var hzhuang = document.getElementById(<span class="string">"hzhuang"</span>);</span><br><span class="line">var output = outputAttribute(hzhuang);</span><br><span class="line">console.log(output);//id=<span class="string">'hzhuang'</span> name=<span class="string">'hzhuang'</span> dir=<span class="string">'ltr'</span> class=<span class="string">'hzhuang'</span> title=<span class="string">'hzhuang'</span></span><br></pre></td></tr></table></figure></p>
<p>####5.创建元素<br>cteateElement()来实现，然后使用节点添加的方法加到DOM中。<br>几个兼容性问题及解决：<br>兼容性：</p>
<ul>
<li>不能设置动态创建的iframe的name特性。</li>
<li>不同用reset()方法充值动态创建的input元素。</li>
<li>动态创建type是reset的button元素重设不了表单。</li>
<li>动态创建的一批name相同的单选按钮彼此之间没有联系。</li>
</ul>
<p>解决方法：<br>检测浏览器(只有IE7及以下支持这种写法)<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">client</span>.browser.ie &amp;&amp; <span class="keyword">client</span>.browser.ie &lt;= <span class="number">7</span>)&#123;</span><br><span class="line">	xxx<span class="comment">//使用参数是完整的元素标签。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>####6.元素的子节点<br>元素的childNodes属性包含所有的子节点：元素，文本节点，注释或者处理指令。<br>解析的差异：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">ul</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">li</span>&gt;</span>1<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">li</span>&gt;</span>2<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">li</span>&gt;</span>3<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>IE解析是ul.childNodes中只有三个子节点。</li>
<li>其他浏览器中解析出7个。（加上四个文本节点：空白符）</li>
</ul>
<p>所以采用以下的方法来实现三个<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for<span class="comment">(var i=0, len=element.childNodes.length; i&lt; len; i++)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span><span class="comment">(element.childNodes[i].nodeType == 1)</span>&#123;</span><br><span class="line">		xxx;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>元素也有getElementsByTagName()方法。</p>
<p>###10.1.4 Text类型(3)<br>nodeType == 3<br>nodeValue或者data属性可以访问到文本节点包含的文本。</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">appendData(text)</td>
<td style="text-align:left">将text添加到节点的末尾</td>
</tr>
<tr>
<td style="text-align:left">deleteData(offset, count)</td>
<td style="text-align:left">从offset指定的位置删除count个字符</td>
</tr>
<tr>
<td style="text-align:left">insertData(offset, text)</td>
<td style="text-align:left">从offset指定的位置添加text</td>
</tr>
<tr>
<td style="text-align:left">replaceData(offset,count, text)</td>
<td style="text-align:left">从offset指定的位置用text替换count个字符</td>
</tr>
<tr>
<td style="text-align:left">splitText(offset)</td>
<td style="text-align:left">指定的位置将当前文本节点分成两个文本节点。</td>
</tr>
<tr>
<td style="text-align:left">substringData(offset, count)</td>
<td style="text-align:left">提取从指定位置offset到offset+count位置处的字符串。</td>
</tr>
</tbody>
</table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeText</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line">	div.firstChild.nodeValue = <span class="string">"Some &lt;strong&gt;other&lt;/strong&gt; message"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后面的符号不需要转义，因为这个字符串会经过HTML编码。</span></span><br></pre></td></tr></table></figure>
<p>####1.创建文本节点<br>document.createTextNode()，然后使用添加节点的方式将它放进DOM。<br>如果添加两个相邻的文本节点，会将两个直接连接起来。且没有空格。但是还是存在两个文本节点。则使用规范化来解决这个问题。</p>
<p>####2.规范化文本节点<br>normalize()在包含一个或者几个文本节点的父节点上调用这个方法，则可以将所有的文本节点合并成一个。也就是说此时element.childNodes.length是等于1的。</p>
<p>####3.分割文本节点<br>splitText()方法的作用域normalize()的作用相反。</p>
<h3 id="10-1-5_Comment类型(8)">10.1.5 Comment类型(8)</h3><p>nodeType == 8<br>类似Text类型</p>
<h3 id="10-1-7_DocumentType类型(x)">10.1.7 DocumentType类型(x)</h3><p>不常用。</p>
<h3 id="10-1-8_DocumentFragment类型(11)">10.1.8 DocumentFragment类型(11)</h3><p>nodeType == 11<br>不可以直接添加在文档中，但是可以作为仓库来使用。<br>创建方法：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br></pre></td></tr></table></figure></p>
<p>看一个例子就明白了：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">"myList"</span>&gt;&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">"myList"</span>);</span><br><span class="line"><span class="keyword">var</span> li = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">	li = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">	li.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Item "</span> + (i+<span class="number">1</span>)));</span><br><span class="line">	fragment.appendChild(li);</span><br><span class="line">&#125;</span><br><span class="line">ul.appendChild(fragment);</span><br></pre></td></tr></table></figure></p>
<h2 id="11-2_DOM操作技术">11.2 DOM操作技术</h2><h3 id="11-2-1_动态脚本">11.2.1 动态脚本</h3><p>页面加载完的时候不存在，在将来的某一个时刻修改DOM动态添加的脚本。</p>
<ul>
<li>插入外部文件。</li>
<li>直接插入js代码。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = documet.createElement(<span class="string">"script"</span>);</span><br><span class="line">script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">script.src = <span class="string">"client.js"</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line"></span><br><span class="line"><span class="comment">//封装成函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> script = documet.createElement(<span class="string">"script"</span>);</span><br><span class="line">	script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">	script.src = url;</span><br><span class="line">	<span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种方式：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="actionscript"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">sayHi</span><span class="params">()</span></span>&#123;</span><br><span class="line">		alert(:hi);</span><br><span class="line">	&#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>要动态创建以上的那个js，则要考虑到兼容性的问题</p>
<ul>
<li>document.createTextNode(“function sayHi(){alert(‘hi’)}”除了IE浏览器不支持外，其他的均支持。 但是可以指定script标签的text属性来指定代码。</li>
<li>但是sarafi3.0之前的不支持text的属性。</li>
</ul>
<p>所以，以下就是封装好的函数，兼容性解决的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScriptString</span>(<span class="params">code</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">	script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		script.appendChild(<span class="built_in">document</span>.createTextNode(code));</span><br><span class="line">	&#125; <span class="keyword">catch</span> (ex)&#123;</span><br><span class="line">		script.appendChild(script.text = code);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="10-2-2_动态样式">10.2.2 动态样式</h3><p>也是两种方式<br>与script类似，但是区别的是link是放在head中的。封装好的函数如下。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadStyleString</span>(<span class="params">css</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> style = <span class="built_in">document</span>.createElement(<span class="string">"style"</span>);</span><br><span class="line">	style.type = <span class="string">"text/css"</span>;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		style.appendChild(<span class="built_in">document</span>.createTextNode(css));</span><br><span class="line">	&#125; <span class="keyword">catch</span> (ex)&#123;</span><br><span class="line">		style.styleSheet.cssText = css;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>];</span><br><span class="line">	head.appendChild(style);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="10-2-3_操作表格">10.2.3 操作表格</h3><p>忽略</p>
<h3 id="10-2-4_使用NodeList">10.2.4 使用NodeList</h3><p>理解”NodeList”以及”nameNodeMap”和”HTMLCollection”是理解DOM的关键。<br>他们是三个集合，而且是动态的，随着DOM的变化得到更新。<br>以下的例子会进入无限循环</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var divs = document.getElementsByTagName(<span class="string">"div"</span>) ,i, <span class="keyword">div</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; divs.<span class="property">length</span>; i++)&#123;</span><br><span class="line">	<span class="keyword">div</span> = document.createElement(<span class="string">"div"</span>);</span><br><span class="line">	document.body.appendChild(<span class="keyword">div</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决方法是只要把divs.length赋值给len，然后使用i小于len即可。</p>
<p>#第11章 DOM扩展</p>
<ul>
<li>Selector API</li>
<li>HTML5扩展</li>
<li>了解专有的DOM扩展</li>
</ul>
<h2 id="11-1_选择符_API">11.1 选择符 API</h2><p>扩展这个API是为了让原生浏览器支持css查询。</p>
<h3 id="11-1-1_querySelector()方法">11.1.1 querySelector()方法</h3><p>接收一个css选择符，返回与该模式匹配的第一个元素。<br>document.querySelector()在整个文档查找<br>element.querySelector()则只会在element的后代中查找匹配项。</p>
<h3 id="11-1-2_querySelectorAll()">11.1.2 querySelectorAll()</h3><p>这个方法与querySelector类似，但是返回的是一个nodeList对象。可以用item()方法来得到各项。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">var</span> <span class="keyword">strong </span>= document.querySelectorAll(<span class="string">"p strong"</span>)<span class="comment">;</span></span><br><span class="line"><span class="label">var</span> i , len<span class="comment">;</span></span><br><span class="line"><span class="label">for</span>(i = <span class="number">0</span> , len = <span class="keyword">strong.length </span><span class="comment">; i++)&#123;</span></span><br><span class="line">	 // <span class="keyword">strong </span>= <span class="keyword">strong[i];</span><br><span class="line"></span>	 <span class="keyword">strong </span>= <span class="keyword">strong.item(i);</span><br><span class="line"></span>	 <span class="keyword">strong.className </span>= <span class="string">"important"</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="11-1-3_matchesSelector()">11.1.3 matchesSelector()</h3><p>这个是element类型的一个方法。返回的是一个布尔值。<br>考虑兼容性问题，封装一个函数里。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function matchesSelect<span class="subst">or</span>(eleement, <span class="keyword">select</span><span class="subst">or</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(element<span class="built_in">.</span>matchesSelect<span class="subst">or</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> element<span class="built_in">.</span>matchesSelect<span class="subst">or</span>(<span class="keyword">select</span><span class="subst">or</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(element<span class="built_in">.</span>msMatchesSelect<span class="subst">or</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> element<span class="built_in">.</span>msMatchesSelect<span class="subst">or</span>(<span class="keyword">select</span><span class="subst">or</span>);</span><br><span class="line">	&#125;<span class="attribute">...</span><span class="attribute">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="11-2_元素遍历">11.2 元素遍历</h2><p>之前讨论过IE和其他浏览器中关于childNodes中包含空格符的不一致问题，现在为了解决这个问题，Element Traversal规范定义一组新的属性。</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">childElementCount</td>
<td style="text-align:left">返回子元素，不包含文本节点和注释</td>
</tr>
<tr>
<td style="text-align:left">firstElementChild</td>
<td style="text-align:left">指向第一个子元素</td>
</tr>
<tr>
<td style="text-align:left">lastElementChild</td>
<td style="text-align:left">指向最后一个子元素</td>
</tr>
<tr>
<td style="text-align:left">previousElementSibling</td>
<td style="text-align:left">指向前一个同辈元素</td>
</tr>
<tr>
<td style="text-align:left">nextElememntSibling</td>
<td style="text-align:left">指向下一个同辈元素</td>
</tr>
</tbody>
</table>
<h2 id="11-3_HTML5">11.3 HTML5</h2><p>###11.3.1与类相关的扩充</p>
<p>####1.getElementsByClassName()<br>H5新加了getElementsByClassName()方法。返回的是得到的所有匹配类的NodeList。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> allCurrentUserNames = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"username current"</span>);</span><br><span class="line"><span class="keyword">var</span> selected = <span class="built_in">document</span>.getElememntById(<span class="string">"myDiv"</span>).getElementsByClassName(<span class="string">"selected"</span>);</span><br></pre></td></tr></table></figure></p>
<p>####2.classList属性<br>可以使用className属性来添加、删除和替换类名。<br>一般，如果要把如下中的类b删除<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"a b c"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>代码如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"a b c"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>)[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> className = div.className.split(<span class="regexp">/\s+/</span>);</span><br><span class="line"><span class="built_in">console</span>.log(className);</span><br><span class="line"><span class="keyword">var</span> pos = -<span class="number">1</span>,</span><br><span class="line">i,</span><br><span class="line">len;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>,len = className.length; i&lt; len ;i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(className[i] = <span class="string">"b"</span>)&#123;</span><br><span class="line">		pos = i;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">className.splice(i, <span class="number">1</span>);</span><br><span class="line">div.className = className.join(<span class="string">" "</span>);</span><br><span class="line"><span class="built_in">console</span>.log(div.className);</span></span><br></pre></td></tr></table></figure></p>
<p>可以有更简单且更安全的方法：HTML5新增的一种操作类名的方式，就是为每个元素添加classList属性。<br>classList是集合DOMTokenList的实例。类似NodeList。<br>当然就可以用item()方法来访问了。<br>同时还定义几个方法：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">add(value)</td>
<td style="text-align:left">给定的字符串组添加到列表中。</td>
</tr>
<tr>
<td style="text-align:left">contains(value)</td>
<td style="text-align:left">检测列表中是否存在value类，返回布尔值。</td>
</tr>
<tr>
<td style="text-align:left">remove(value)</td>
<td style="text-align:left">显而易见的意思</td>
</tr>
<tr>
<td style="text-align:left">toggle(value)</td>
<td style="text-align:left">存在就删除，不存在就添加。</td>
</tr>
</tbody>
</table>
<p>所以，可见，之前很多行代码可以使用一行就解决了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>)[<span class="number">1</span>].classList.remove(<span class="string">"b"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(div); <span class="comment">//undefined,说明没有返回值。</span></span><br></pre></td></tr></table></figure></p>
<p>###11.3.2 焦点管理<br>H5添加富足管理DOM焦点的功能:document.<strong>activeElement属性</strong>。<br>元素获得焦点的方式：</p>
<ul>
<li>页面加载</li>
<li>用户输入</li>
<li>调用focus()方法</li>
</ul>
<p>加载期间，activeElement属性是null，加载完之后默认的是document.body。</p>
<p>一个方法：document.hasFocus()，用于确定文档是否获得了焦点。</p>
<h3 id="11-3-3_HTMLDocument的变化">11.3.3 HTMLDocument的变化</h3><h4 id="1-readyState属性">1.readyState属性</h4><p>有两个可能的值：</p>
<ul>
<li>loading</li>
<li>complete</li>
</ul>
<p>这个属性最好的用法就是用来判断文档是否加载完全。<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">document</span>.readyState == <span class="string">"complete"</span>)&#123;xxx&#125;</span><br></pre></td></tr></table></figure></p>
<p>####2.兼容模式<br>区分渲染页面是标准模式还是混合模式，CompatMode属性来判断：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">document</span>.compatMode == <span class="string">"CSS1Compat"</span>)&#123; <span class="comment">//css要大写</span></span><br><span class="line">	alert(<span class="string">"标准模式"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">document</span>.compatMode == <span class="string">"BackCompat"</span>)&#123;</span><br><span class="line">	alert(<span class="string">"混合模式"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>####3.head属性<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> head = <span class="built_in">document</span>.head || <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>];</span><br></pre></td></tr></table></figure></p>
<h3 id="11-3-4_字符集属性">11.3.4 字符集属性</h3><p>charset属性<br>常用的设置UTF-8的操作就是这个。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>可以用document.charset访问到文档中的字符集，默认的是UTF-16。</p>
<h3 id="11-3-5_自定义数据属性">11.3.5 自定义数据属性</h3><p>对于H5页面中自定义的属性，原生js可以通过元素的dataset属性来访问自定义的值。这个属性是<strong>DONStringMap</strong>的实例，是一个名值对的映射。<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"hzhuang"</span> <span class="attribute">data-id</span> = "<span class="attribute">1</span>" <span class="attribute">data-name</span> = "<span class="attribute">hzhuang</span>"&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"hzhuang"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(div);<span class="comment">//DOMStringMap </span></span></span><span class="expression">&#123;<span class="variable">id</span>: <span class="string">"1"</span>, <span class="variable">name</span>: <span class="string">"hzhuang"</span>&#125;</span><span class="xml"><span class="undefined"></span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="11-3-6_插入标记">11.3.6 插入标记</h3><p>####1. innerHTML属性<br>兼容性，有的浏览器返回的标签全变成大写。<br>IE浏览器使用限制：</p>
<ul>
<li>插入script元素必须制定defer属性。</li>
<li>script元素必须位于有作用域的元素之后。script元素在页面中看不见，所以是无作用域的。<br>对于解决方法：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div.innerHTML = "_<span class="tag">&lt;<span class="title">script</span> <span class="attribute">defer</span>&gt;</span><span class="handlebars"><span class="xml">alert('123')\<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="handlebars"><span class="xml">";</span><br><span class="line">div.innerHTML = "<span class="tag">&lt;<span class="title">div</span>&gt;</span>&amp;nbsp;<span class="tag">&lt;<span class="title">script</span> <span class="attribute">defer</span>&gt;</span><span class="handlebars"><span class="xml">alert('123')\<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="handlebars"><span class="xml">";</span><br><span class="line">div.innerHTML = "<span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span> = \"<span class="attribute">hidden</span>\"&gt;</span><span class="tag">&lt;<span class="title">script</span> <span class="attribute">defer</span>&gt;</span><span class="handlebars"><span class="xml">alert('123')\<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="undefined">"; //首选</span></span></span></span></span></span></span></span></span></span></span></span><br></pre></td></tr></table></figure>
<p>对于style就类似了。</p>
<p>还有很多元素是不支持这个属性的，如：head，html，style，表格相关元素，title等……</p>
<p>####2.outerHTML属性<br>与innerHTML相似，但是返回的是包括元素本身的。用于读取或者设置DOM结构。</p>
<p>####3.insertAdjacentHTML()方法<br>接受插入位置和要插入的HTML两个参数。<br>接受插入的位置有四个值：beforebegin，afterbegin，beforeend和afterend。</p>
<table>
<thead>
<tr>
<th style="text-align:left">插入位置</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">beforebegin</td>
<td style="text-align:left">当前元素的前面插入一个紧邻的同辈元素</td>
</tr>
<tr>
<td style="text-align:left">afterend</td>
<td style="text-align:left">当前元素的后面插入一个紧邻的同辈元素</td>
</tr>
<tr>
<td style="text-align:left">afterbegin</td>
<td style="text-align:left">当前元素之下插入一个子元素。第一个子元素之前</td>
</tr>
<tr>
<td style="text-align:left">beforeend</td>
<td style="text-align:left">当前元素之下插入一个子元素。最后的子元素之后</td>
</tr>
</tbody>
</table>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">div</span>.insertAdjacentHTML(<span class="string">"beforebegin"</span>, <span class="string">"hzhuang"</span>);</span><br></pre></td></tr></table></figure>
<p>####4.内存与性能问题<br>使用这些方法设置新的HTML的时候，之前被删掉的还是占用内存的。</p>
<h3 id="11-3-7_scrolltoView()方法。">11.3.7 scrolltoView()方法。</h3><p>通过滚动浏览器窗口或者某个元素，调用元素就可以出现在视口中。</p>
<ul>
<li>传入的参数是true或者没有的话，窗口滚动之后会让调用元素的顶部与视口顶部尽可能齐平。</li>
<li>参数是false，则调用元素会尽可能的出现在视口中。</li>
</ul>
<h2 id="11-4专有扩展">11.4专有扩展</h2><p>就是不同的浏览器自己做的扩展，但是最终在H5中得到标准化。</p>
<p>###11.4.1 文档模式</p>
<p>###11.4.2 children属性<br>解决childNodes属性的差异而诞生的，children属性是HTMLCollection的实例。和childNodes很类似，但是IE9中改进，不包括注释节点。</p>
<p>###11.4.3 contains()方法<br>contains()方法用来检测摸个元素是否有某个后代。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">document</span><span class="class">.documentElement</span><span class="class">.contains</span>(<span class="tag">document</span><span class="class">.body</span>);</span><br></pre></td></tr></table></figure></p>
<p>方法并不是只有这一个，<strong>compareDocumentPosition()</strong>也可以做到，这个方法是用于确定两个节点之间的关系。返回的是表示关系的数字。<br>其中参数就是给定的节点。</p>
<table>
<thead>
<tr>
<th style="text-align:left">返回的数字</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">表示两个节点无关</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">给点节点在参考节点的前面</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">给点节点在参考节点的后面</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">给定的节点是包含节点的祖先</td>
</tr>
<tr>
<td style="text-align:left">16</td>
<td style="text-align:left">给点的节点是参考节点的后代</td>
</tr>
</tbody>
</table>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">result</span> = document.documentElement.compareDocumentPosition(document.body);</span><br><span class="line">console.log(<span class="literal">result</span>);//<span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>通用的contains函数：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">contains</span><span class="params">(resNode, otherNode)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">typeof</span> refNode.contains  == <span class="string">"function"</span> &amp;&amp; (!client.engine.webkit || client.engine.webkit &gt;=<span class="number">552</span>) )&#123;</span><br><span class="line">		<span class="keyword">return</span> resNode.contains(otherNode);</span><br><span class="line"> 	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(type compareDocumentPosition == <span class="string">"function"</span>)&#123;</span><br><span class="line"> 		<span class="keyword">return</span> !!(refNode.compareDocumentPosition(other) &amp; <span class="number">16</span>);<span class="comment">//</span></span><br><span class="line"> 		<span class="comment">//!!(x)的作用是如果x是nuu或者undefined的话，返回的是false。</span></span><br><span class="line"> 	&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"> 		<span class="keyword">var</span> node = otherNode.parentNode;</span><br><span class="line"> 		<span class="keyword">do</span>&#123;</span><br><span class="line"> 			<span class="keyword">if</span>(node === refNode)&#123;</span><br><span class="line"> 				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> 			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> 				node = node.parentNode;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;<span class="keyword">while</span>(node !== <span class="literal">null</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="11-4-4_插入文本">11.4.4 插入文本</h3><p>innerText和outerText没有被纳入H5的规范。</p>
<h3 id="11-4-5_滚动">11.4.5 滚动</h3><p>几个扩展的方法：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">scrollToViewIfNeeded(alignCeter)</td>
<td style="text-align:left">只有在当前的元素在视口中不可见的情况下，才滚动</td>
</tr>
<tr>
<td style="text-align:left">scrollByLines(lineCount)</td>
<td style="text-align:left">将元素的内容滚动到指定的行高</td>
</tr>
<tr>
<td style="text-align:left">scrollByPages(pageCount)</td>
<td style="text-align:left">将元素的内容滚动到指定的页面高度</td>
</tr>
</tbody>
</table>
<h1 id="第12章_DOM2和DOM3">第12章 DOM2和DOM3</h1><p>引入了更多的交互能力功能以模块的方式引入。<br>模块：<br>  核心++视图++事件++样式++遍历和范围++HTMl</p>
<h2 id="12-1_DOM变化">12.1 DOM变化</h2><p>检测浏览是否支持DOM模块，可以使用上章中的检测方法。<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.implementation.hasFeature(<span class="string">"views"</span>, <span class="string">"2.0"</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h3 id="21-1-1_针对XML命名空间的变化">21.1.1 针对XML命名空间的变化</h3><p>####1 node类型的变化</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">localName</td>
<td style="text-align:left">不带命名空间前缀的节点名称</td>
</tr>
<tr>
<td style="text-align:left">nameSpaceURL</td>
<td style="text-align:left">命名空间URL或者null</td>
</tr>
<tr>
<td style="text-align:left">prefix</td>
<td style="text-align:left">命名空间前缀</td>
</tr>
</tbody>
</table>
<p>DOM3中</p>
<p>#第25章 新兴的API<br>内容：</p>
<ul>
<li>创建平滑的动画</li>
<li>操作文件</li>
<li>使用Web Workers在后台执行Js</li>
</ul>
<h2 id="25-1_requestAnimationFrame(_)">25.1 requestAnimationFrame( )</h2><h3 id="早期动画循环">早期动画循环</h3><p>使用setInterval( )来实现。<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">function</span><span class="list">()</span><span class="collection">&#123;</span><br><span class="line">	function updateAnimation<span class="list">()</span><span class="collection">&#123;</span><br><span class="line">		doAnimation1<span class="list">()</span><span class="comment">;</span></span><br><span class="line">		doAnimation2<span class="list">()</span><span class="comment">;</span></span><br><span class="line">	&#125;</span><span class="comment">;</span></span><br><span class="line">	setInterval<span class="list">(<span class="keyword">updateAnimation</span>, <span class="number">100</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;</span>)</span><span class="list">()</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>问题：<br>setInterval( )和setTimeout( )都不是十分的精确。传入第二个参数，实际只是指定了把动画代码添加到浏览器UI线程队列中<strong>以等待执行的时间</strong>。如果队列的前面已经加入了其他任务，那动画代码就要等前面的任务完成后再执行。</p>
<p>###25.1.2 循环间隔的问题<br>浏览器的计数器的精度：各不相同。<br>IE9+:4ms/Firefox+safari:10ms/chrome:4ms<br>所以在不同的浏览器中即使设置相同时间的等待时间，性能也会有区别。</p>
<h3 id="25-1-3_mozRequestAnimationFrame">25.1.3 mozRequestAnimationFrame</h3><p>css变换和动画的优势在于浏览器知道动画什么时候开始，因此会计算出正确的循环讲个。<br>mozRequestAnimationFrame( )告诉浏览区某些js代码要执行动画。它接受一个参数，即在重绘屏幕前调用的一个函数。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">继续</span><br></pre></td></tr></table></figure></p>
<h2 id="25-2_Page_Visibility_API">25.2 Page Visibility API</h2><p>为了让开发人员知道页面是否对用户可见而推出的。</p>
<table>
<thead>
<tr>
<th style="text-align:left">API组成部分</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">document.hidden</td>
<td style="text-align:left">页面是否隐藏的布尔值。页面隐藏包括页面在后台标签或者浏览器最小化。</td>
</tr>
<tr>
<td style="text-align:left">document.visibilityState</td>
<td style="text-align:left">4个可能的值：后台或者最小化、前台标签页中、实际的页面已经隐藏，但是 用户可以预览页面和页面在屏幕外执行预渲染处理。</td>
</tr>
<tr>
<td style="text-align:left">visibilitychange事件</td>
<td style="text-align:left">文档从可见变成不可见或从不可见变成可见时，触发该事件。</td>
</tr>
</tbody>
</table>
<p>此API只有IE10和chrome支持，检测的代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isHiddenSupported</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">typeof</span>(<span class="built_in">document</span>.hidden || <span class="built_in">document</span>.msHidden || <span class="built_in">document</span>.webkitHidden) != <span class="string">"undefined"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleVisibilityChange</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> output = <span class="built_in">document</span>.getElementById(<span class="string">"output"</span>);</span><br><span class="line">	<span class="keyword">var</span> msg;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">document</span>.hidden || <span class="built_in">document</span>.msHidden || <span class="built_in">document</span>.webkitHidden)&#123;</span><br><span class="line">		msg = <span class="string">"hidden"</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		msg = <span class="string">"visibility"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	output.innerHTML += msg;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//EventUtil.addHandler是base.js中得到的。</span></span><br><span class="line">EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">"msvisibilitychange"</span>, handleVisibilityChange);</span><br><span class="line">EventUtil.addhandler(<span class="built_in">document</span>, <span class="string">"webkitvisibilitychange"</span>, handleVisibilityChange);</span><br></pre></td></tr></table></figure></p>
<p>对于document.visibilityState，IE的值和chrome的值是不一样的，chrome是三个：“hidden”,”visible”,”prerender”。IE暂时忽略，</p>
<h2 id="25-3_Geolocation_API">25.3 Geolocation API</h2><p>访问之前 必须要得到用户的明确许可，在页面中共享其位置信息。<br><strong>navigator.geolocation对象</strong>，这个对象包含三个方法：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">用法参数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">getCurrentPosition( )</td>
<td style="text-align:left">触发请求用户共享地理定位信息的对话框。</td>
<td style="text-align:left">三个参数：成功回调函数，可选的失败回调函数以及可选的选项对象。</td>
</tr>
<tr>
<td style="text-align:left">watchPosition( )</td>
<td style="text-align:left">跟踪用户的信息</td>
<td style="text-align:left">参数和上一个完全相同</td>
</tr>
<tr>
<td style="text-align:left">clearWatch( )</td>
<td style="text-align:left">用于取消watchPosition( )的监控</td>
<td style="text-align:left">xx</td>
</tr>
</tbody>
</table>
<p>成功回调函数会接受到一个Position对象参数；Position对象有两个属性：<strong>coords</strong>和<strong>timestamp</strong>。<br>coords包含的信息：</p>
<ul>
<li>latitude：十进制的形式表示的维度</li>
<li>longitude: 十进制的形式表示的经度</li>
<li>accuracy：精度</li>
<li>其他浏览器还有……</li>
</ul>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">navigator.geolocation.getCurrentPosition(<span class="function"><span class="keyword">function</span><span class="params">(position)</span></span>&#123;</span><br><span class="line">	logdrawMapCenteredAt(<span class="keyword">position</span>.coords.latitude,<span class="keyword">position</span>.coords.longitude);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>失败回调函数，返回的是一个对象，有<strong>message</strong>和<strong>code</strong>两个属性。message中的信息解释为什么错误；code属性是一个数组，表示的是错误的类型。<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">navigator.geolocation.getCurrentPosition(<span class="function"><span class="keyword">function</span><span class="params">(position)</span></span>&#123;</span><br><span class="line">	logdrawMapCenteredAt(<span class="keyword">position</span>.coords.latitude,<span class="keyword">position</span>.coords.longitude);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span><span class="params">(error)</span></span>&#123;</span><br><span class="line">	console.<span class="built_in">log</span>(error.message);</span><br><span class="line">	console.<span class="built_in">log</span>(error.code);</span><br><span class="line">&#125;,&#123;</span><br><span class="line">	enableHigeAccuracy: true,</span><br><span class="line">	timeout: <span class="number">5000</span>,</span><br><span class="line">	maximumAge: <span class="number">25000</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>第三个参数用于设定信息的类型。是一个选项对象。</p>
<ul>
<li>enableHighAccuracy是一个boolean值，表示必须尽肯呢个的使用最准确的位置信息。</li>
<li>timeout表示等待位置信息的最长时间。</li>
<li>maximumAge表示上一次取得坐标信息的有效时间。</li>
</ul>
<blockquote>
<p>watchPosition( )起到定时调用getCurrentPosition( )的效果。</p>
</blockquote>
<p>watchPosition( )返回一个数值标识符。如果要取消监控，则使用clearWatch( )方法。</p>
<p>##25.4 File API<br>在文职输入字段的基础上，添加一些直接访问文件信息的接口。H5在DOM中为文件输入元素添加了一个files集合，files集合中包含一组<strong>File对象</strong>，每个File对象就对应着一个文件。<br>File对象的只读属性：</p>
<ul>
<li>name</li>
<li>size</li>
<li>type</li>
<li>lastModifiedDate</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> fileLists = <span class="built_in">document</span>.getElementById(<span class="string">"file-lists"</span>);</span><br><span class="line">	EventUtil.addHandler(fileLists, <span class="string">"change"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> files = EventUtil.getTarget(event).files,i=<span class="number">0</span>,len = files.length;</span><br><span class="line">		<span class="keyword">while</span>(i &lt; len)&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(files[i].name + <span class="string">"("</span> + files[i].type + <span class="string">","</span> + files[i].size + <span class="string">"bites)"</span>);</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###25.4.1 FileReader类型<br>读取文件系统提供的方法：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">readAsText(file, encoding)</td>
<td style="text-align:left">以纯文本形式读取文件，将读取到的文本保存在result属性中。</td>
</tr>
<tr>
<td style="text-align:left">readAsDataURL(file)</td>
<td style="text-align:left">读取文件并且以数据URL的形式保存在result中。</td>
</tr>
<tr>
<td style="text-align:left">readAsBinaryString(file)</td>
<td style="text-align:left">读取文件并将一个字符串保存在result属性中。</td>
</tr>
<tr>
<td style="text-align:left">readAsArrayBuffer(file)</td>
<td style="text-align:left">读取文件并将一个包含文件内容的ArrayBuffer保存在result中。</td>
</tr>
</tbody>
</table>
<p>读取文件也是<strong>异步的</strong>，所以也会包括几个事件：</p>
<ul>
<li>progress：获得lengthComputable，loaded和total属性。</li>
<li>error：返回error属性。五种错误。</li>
<li>load：读取成功时候调用。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> fileLists = <span class="built_in">document</span>.getElementById(<span class="string">"file-lists"</span>);</span><br><span class="line">	EventUtil.addHandler(fileLists, <span class="string">"change"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> info = <span class="string">""</span>,</span><br><span class="line">		output = <span class="built_in">document</span>.getElementById(<span class="string">"output"</span>),</span><br><span class="line">		progress = <span class="built_in">document</span>.getElementById(<span class="string">"progress"</span>),</span><br><span class="line">		files = EventUtil.getTarget(event).files,</span><br><span class="line">		type = <span class="string">"default"</span>,</span><br><span class="line">		reader = <span class="keyword">new</span> FileReader();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(<span class="regexp">/image/</span>.test(files[<span class="number">0</span>].type))&#123;</span><br><span class="line">			reader.readAsDataURL(files[<span class="number">0</span>]);</span><br><span class="line">			type = <span class="string">"image"</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			reader.readAsText(files[<span class="number">0</span>]);</span><br><span class="line">			type = <span class="string">"text"</span>;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		reader.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			output.innerHTML = <span class="string">"Could not read file, error code is "</span> + reader.error.code;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		reader.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(event.lengthComputable)&#123;</span><br><span class="line">				progress.innerHTML = event.loaded + <span class="string">"/"</span> + event.total;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">var</span> html = <span class="string">""</span>;</span><br><span class="line">			<span class="keyword">switch</span>(type)&#123;</span><br><span class="line">				<span class="keyword">case</span> <span class="string">"image"</span>:</span><br><span class="line">				html = <span class="string">"&lt;img src=\""</span> + reader.result + <span class="string">"\"&gt;"</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="string">"text"</span>:</span><br><span class="line">				heml = reader.result;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			output.innerHTML = html;</span><br><span class="line">			<span class="built_in">console</span>.log(reader.result);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>abort( )方法可以停止以上过程。</p>
<p>###25.4.2 读取部分内容<br>如果想读取文件的部分内容，File对象还支持一个slice( )方法。在火狐浏览器中加入moz，在chrome中要加入webkit。<br>slice( )支持两个参数：第一个起始字节，第二个是读取的字节数。<br><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">blobSlice</span><span class="params">(blob, startByte, length)</span>&#123;</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="transposed_variable">blob.</span>slice)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="transposed_variable">blob.</span>slice(startByte, <span class="built_in">length</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="transposed_variable">blob.</span>webkit)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="transposed_variable">blob.</span>webkitSlice(startByte, <span class="built_in">length</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="transposed_variable">blob.</span>mozslice)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="transposed_variable">blob.</span>mozSlice(startByte, <span class="built_in">length</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> null;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Blob类型有一个size属性和type属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> fileLists = <span class="built_in">document</span>.getElementById(<span class="string">"file-lists"</span>);</span><br><span class="line">	EventUtil.addHandler(fileLists, <span class="string">"change"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> info = <span class="string">""</span>,</span><br><span class="line">		output = <span class="built_in">document</span>.getElementById(<span class="string">"output"</span>),</span><br><span class="line">		progress = <span class="built_in">document</span>.getElementById(<span class="string">"progress"</span>),</span><br><span class="line">		files = EventUtil.getTarget(event).files,</span><br><span class="line">		type = <span class="string">"default"</span>,</span><br><span class="line">		reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">		blob = blobSlice(files[<span class="number">0</span>], <span class="number">0</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(blob)&#123;</span><br><span class="line">			reader.readAsText(blob);</span><br><span class="line"></span><br><span class="line">			reader.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">				output.innerHTML = <span class="string">"Could not read file, error code is "</span> + reader.error.code;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			reader.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(event.lengthComputable)&#123;</span><br><span class="line">					progress.innerHTML = event.loaded + <span class="string">"/"</span> + event.total;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">				<span class="keyword">var</span> html = <span class="string">""</span>;</span><br><span class="line">				<span class="keyword">switch</span>(type)&#123;</span><br><span class="line">					<span class="keyword">case</span> <span class="string">"image"</span>:</span><br><span class="line">					html = <span class="string">"&lt;img src=\""</span> + reader.result + <span class="string">"\"&gt;"</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="string">"text"</span>:</span><br><span class="line">					heml = reader.result;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				output.innerHTML = html;</span><br><span class="line">				<span class="built_in">console</span>.log(reader.result);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			alert(<span class="string">"Your browser doesn't support slice()."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">blobSlice</span>(<span class="params">blob, startByte, length</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(blob.slice)&#123;</span><br><span class="line">		<span class="keyword">return</span> blob.slice(startByte, length);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(blob.webkit)&#123;</span><br><span class="line">		<span class="keyword">return</span> blob.webkitSlice(startByte, length);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(blob.mozslice)&#123;</span><br><span class="line">		<span class="keyword">return</span> blob.mozSlice(startByte, length);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###25.4.3 对象URL</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/11/26/whlove-record-introduction/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          武汉高校之恋-语音介绍页面实现总结
        
      </div>
    </a>
  
  
    <a href="/2015/09/20/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Hello World</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="javascript-3th" data-title="javascript高级程序设计第三版笔记（持续更新）" data-url="http://huangzhuang.github.io/2015/11/08/javascript-3th/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 hzhuang
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>